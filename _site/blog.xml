<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:distill="https://distill.pub/journal/" version="2.0">
  <channel>
    <title>Franklin Santos</title>
    <link>https://franklinsantos.com</link>
    <atom:link href="https://franklinsantos.com/blog.xml" rel="self" type="application/rss+xml"/>
    <description>Data Scientist, Plant Breeder and Analist Data
</description>
    <generator>Distill</generator>
    <lastBuildDate>Tue, 01 Mar 2022 00:00:00 +0000</lastBuildDate>
    <item>
      <title>Introducción a Machine Learning</title>
      <dc:creator>Franklin Santos</dc:creator>
      <link>https://franklinsantos.com/posts/2022-03-01-intro-ml</link>
      <description>


&lt;h1 id="introducción-a-machine-learning"&gt;Introducción a Machine
Learning&lt;/h1&gt;
&lt;p&gt;Aprenda los fundamentos del aprendizaje automático, incluidos casos
de uso y diferentes técnicas de aprendizaje. Diferenciar entre regresión
y clasificación.&lt;/p&gt;
&lt;p&gt;¿Qué es Machine Learning?&lt;/p&gt;
&lt;p&gt;En los últimos años, términos como inteligencia artificial,
aprendizaje automático y aprendizaje profundo se han utilizado mucho.
Tan misteriosas como suenan estas palabras, ¿cuál es su diferencia y de
qué son capaces?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Diferenciar entre inteligencia artificial, aprendizaje automático y
aprendizaje profundo&lt;/li&gt;
&lt;li&gt;Identificar casos de uso de Machine Learning&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-03-01-intro-ml/int.png" /&gt;&lt;/p&gt;
&lt;h2 id="inteligencia-artificial"&gt;Inteligencia artificial&lt;/h2&gt;
&lt;p&gt;La &lt;strong&gt;inteligencia artificial (IA)&lt;/strong&gt; es la inteligencia
demostrada por las máquinas, en contraste con la inteligencia natural
asociada con los humanos. Por inteligencia, generalmente nos referimos a
la resolución de problemas y tareas complejos, que aparentemente
requieren algún tipo de habilidades cognitivas. La inteligencia
artificial comenzó como una disciplina académica en la década de 1950
con el supuesto de que las computadoras pueden imitar el complejo
razonamiento dentro del cerebro humano. Este campo también se conoce
como &lt;em&gt;inteligencia artificial general (AGI)&lt;/em&gt; y el objetivo de
alcanzar una inteligencia similar a la humana, incluso hoy, parece estar
fuera de alcance.&lt;/p&gt;
&lt;p&gt;Sin embargo, surgió un subcampo llamado aprendizaje automático
&lt;em&gt;machine learning (ML)&lt;/em&gt; que se centra en problemas más
específicos, como el reconocimiento de imágenes o la comprensión del
lenguaje. Gracias a las aplicaciones de la industria, el aprendizaje
automático se ha vuelto cada vez más popular y atrae a investigadores e
inversores a nivel mundial.&lt;/p&gt;
&lt;h2 id="machine-learning-aprendizaje-automático"&gt;Machine Learning
(Aprendizaje automático)&lt;/h2&gt;
&lt;p&gt;El &lt;strong&gt;machine learning (ML)&lt;/strong&gt; es un subcampo de la
inteligencia artificial. Su objetivo es construir y aplicar modelos
sofisticados sin la necesidad de reglas e instrucciones codificadas. En
cambio, los modelos pueden extraer reglas y patrones de los datos y
aplicarlos para nuevos problemas.&lt;/p&gt;
&lt;p&gt;La recopilación de datos, la anotación y el procesamiento previo son
requisitos previos esenciales para crear modelos de aprendizaje
automático. Como regla general, cuanto mayor es la complejidad de un
modelo, normalmente se necesitan más datos para el entrenamiento y la
validación.&lt;/p&gt;
&lt;p&gt;Por ejemplo, podría pensar en asistentes virtuales avanzados, como &lt;a
href="https://developer.amazon.com/alexa"&gt;Alexa&lt;/a&gt; (Amazon) o &lt;a
href="https://www.apple.com/siri"&gt;Siri&lt;/a&gt; (Apple), que aplican el
aprendizaje automático para interpretar el lenguaje natural y predecir
la mejor respuesta o reacción.&lt;/p&gt;
&lt;h2 id="aprendizaje-profundo-deep-learning"&gt;Aprendizaje profundo (Deep
Learning)&lt;/h2&gt;
&lt;p&gt;El &lt;strong&gt;aprendizaje profundo&lt;/strong&gt; es un área del aprendizaje
automático, que cubre únicamente las redes neuronales. El nombre de red
neuronal se inspiró en el hecho de que la arquitectura modela libremente
el cerebro humano. Esta técnica demostró ser especialmente adecuada para
ciertas tareas como el reconocimiento de imágenes, que es la piedra
angular de aplicaciones como los vehículos autónomos.&lt;/p&gt;
&lt;p&gt;Las redes neuronales profundas son actualmente el área de
investigación más candente en toda la comunidad de IA. Su popularidad se
basa en muchos avances en los últimos años, incluida la competencia
ImageNet que clasifica imágenes en color de alta resolución en 1000
categorías diferentes y 1,2 (1,4) millones de muestras de entrenamiento.
Las redes neuronales profundas también llevaron a avances en otras áreas
en las que se desempeñaron comparables o incluso mejores que sus
contrapartes humanas, incluido el reconocimiento de voz, la
transcripción de escritura a mano (OCR), la traducción automática, la
conducción autónoma, Go playing y muchos más.&lt;/p&gt;
&lt;h2 id="casos-de-uso-populares"&gt;Casos de uso populares&lt;/h2&gt;
&lt;p&gt;A medida que avanzaba el campo del aprendizaje automático y las
computadoras se volvían cada vez más poderosas, se habilitaron nuevas
soluciones que afectaron a casi todos los campos (científicos). Hoy en
día, el aprendizaje automático ayuda a los científicos a realizar
diagnósticos médicos, descubrir nuevos medicamentos, monitorear la
superficie de la tierra y detectar incendios forestales, automatizar y
optimizar procesos en la industria financiera, etc.&lt;/p&gt;
&lt;p&gt;Aparte de estas aplicaciones de vanguardia, a menudo tendemos a pasar
por alto que el aprendizaje automático también forma parte de nuestra
vida diaria. En las siguientes secciones abordaremos estas aplicaciones
de aprendizaje automático y nos centraremos en sistemas como:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sistemas de recomendación&lt;/li&gt;
&lt;li&gt;Los motores de búsqueda&lt;/li&gt;
&lt;li&gt;Máquina traductora&lt;/li&gt;
&lt;li&gt;Identificación de música&lt;/li&gt;
&lt;li&gt;Autos autónomos&lt;/li&gt;
&lt;/ul&gt;
&lt;h3
id="caso-de-uso-motores-de-búsqueda-y-sistemas-de-recomendación"&gt;Caso de
uso: motores de búsqueda y sistemas de recomendación&lt;/h3&gt;
&lt;p&gt;Los &lt;strong&gt;motores de búsqueda&lt;/strong&gt;, como Google, aplican el
aprendizaje automático de muchas formas para brindar mejores servicios.
Al escribir una consulta, por ejemplo, el aprendizaje automático
proporciona sugerencias de autocompletado. Estas sugerencias se
personalizan en función de los temas de tendencia actual, pero también
de nuestra ubicación y búsquedas anteriores. Posteriormente, las
consultas se evalúan en muchos niveles para determinar nuestras
intenciones exactas y clasificar los resultados en consecuencia.&lt;/p&gt;
&lt;p&gt;De manera similar, el aprendizaje automático determina lo que se nos
recomienda en YouTube, Netflix, Amazon, etc. (un campo del aprendizaje
automático, a menudo denominado &lt;strong&gt;sistemas de
recomendación&lt;/strong&gt;). Estas aplicaciones predicen nuestros intereses
al analizar nuestras actividades en línea. Los artículos que hemos
buscado, las películas que hemos visto, los productos que hemos comprado
son todos predictores sobre nuestro comportamiento e intereses
futuros.&lt;/p&gt;
&lt;h3 id="caso-de-uso-traducción-automática"&gt;Caso de uso: traducción
automática&lt;/h3&gt;
&lt;p&gt;Los servicios de &lt;strong&gt;traducción&lt;/strong&gt; como &lt;a
href="https://www.deepl.com/en/translator"&gt;DeepL&lt;/a&gt; también aplican
cada vez más el aprendizaje automático. La idea principal detrás de
estos servicios es pasar de diccionarios simples a traductores complejos
que se enfocan en el contexto e interpretan el texto como un todo. El
aprendizaje automático en esta configuración se puede utilizar para
crear modelos que describan cómo se expresan ciertas ideas en otros
lenguajes. Esto permite una comprensión más matizada del texto escrito y
proporciona traducciones más naturales. Un aspecto importante de estas
soluciones es que se pueden mejorar constantemente proporcionándoles
nuevos ejemplos y comentarios de los que aprender.&lt;/p&gt;
&lt;h3
id="caso-de-uso-identificación-de-música-y-reconocimiento-de-voz"&gt;Caso
de uso: identificación de música y reconocimiento de voz&lt;/h3&gt;
&lt;p&gt;El análisis de audio es un campo propio en el aprendizaje automático.
Una herramienta común en este campo es transformar señales de audio en
componentes de frecuencia. En el caso de los discos de música, la
composición de estos componentes de frecuencia es tan única, que podemos
definir las llamadas &lt;em&gt;huellas digitales&lt;/em&gt; para cada canción. Esto
habilita aplicaciones de &lt;strong&gt;identificación de música&lt;/strong&gt; como
Shazam, que pueden identificar y unir canciones con precisión basándose
en una muestra de solo unos segundos de duración. Del mismo modo, las
aplicaciones de &lt;strong&gt;reconocimiento de voz&lt;/strong&gt; pueden
identificar fácilmente las palabras habladas y convertirlas en lenguaje
escrito.&lt;/p&gt;
&lt;h3 id="caso-de-uso-coches-autónomos"&gt;Caso de uso: coches autónomos&lt;/h3&gt;
&lt;p&gt;Los &lt;strong&gt;coches autónomos&lt;/strong&gt; como Google Waymo y Tesla
dependen en gran medida del aprendizaje automático. Al analizar los
datos provenientes de varios sensores, el aprendizaje automático
controla la aceleración, frenado y dirección del automóvil. Estas
instrucciones se basan no solo en las normas de tráfico y las señales de
tráfico, sino que incluyen un modelo predictivo continuo para evitar
posibles accidentes. Aunque los modelos finales de aprendizaje
automático son capaces de evaluar los datos de entrada y tomar
decisiones en fracciones de segundo, el entrenamiento de los modelos
requiere inmensas cantidades de datos, poder computacional y tiempo.&lt;/p&gt;
&lt;h2 id="técnicas-de-machine-learning"&gt;Técnicas de Machine Learning&lt;/h2&gt;
&lt;p&gt;En este capítulo&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Familiarízate con diferentes enfoques de machine learning&lt;/li&gt;
&lt;li&gt;Diferenciar entre técnicas de aprendizaje supervisado, no
supervisado y por refuerzo.&lt;/li&gt;
&lt;li&gt;Vea cómo se pueden aplicar las técnicas de aprendizaje para
diferentes casos de uso&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;La idea básica del aprendizaje automático es crear modelos que se
puedan utilizar para hacer predicciones y tomar decisiones.
Diferenciamos entre 3 tipos de aprendizaje automático, cada uno de ellos
tiene como objetivo resolver diferentes tipos de tareas:
&lt;strong&gt;supervisado&lt;/strong&gt;, &lt;strong&gt;no supervisado&lt;/strong&gt; y
&lt;strong&gt;aprendizaje reforzado&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;El &lt;strong&gt;aprendizaje supervisado&lt;/strong&gt; tiene como objetivo
aprender de un conjunto de datos de ejemplo. Nuestra suposición inicial
es que el valor de un resultado conocido (por ejemplo, el cliente compra
un producto) está influenciado por un conjunto de entradas medibles
(edad, intereses, últimos clics). Utilizando algoritmos de aprendizaje
automático, intentamos detectar y modelar estas relaciones.&lt;/p&gt;
&lt;p&gt;El &lt;strong&gt;aprendizaje no supervisado&lt;/strong&gt; también requiere datos
de entrada, pero no existe una variable de resultado predefinida. En su
lugar, tratamos de detectar patrones y establecer relaciones dentro de
los datos (por ejemplo, a través de agrupaciones) o reducir dimensiones
(por ejemplo, con análisis de componentes principales).&lt;/p&gt;
&lt;p&gt;El &lt;strong&gt;aprendizaje reforzado&lt;/strong&gt; no requiere observaciones
de entrada, sino un objetivo y un entorno en el que operar. Al integrar
la retroalimentación continua del entorno, esperamos que el sistema cree
sus propias tácticas para lograr el objetivo.&lt;/p&gt;
&lt;h3 id="aprendizaje-supervisado"&gt;Aprendizaje supervisado&lt;/h3&gt;
&lt;p&gt;En el &lt;em&gt;aprendizaje supervisado&lt;/em&gt;, la variable de resultado debe
conocerse para el entrenamiento de modelos. Como ejemplo, podría pensar
en un modelo para la predicción de precios de apartamentos. Este modelo
podría ayudar a los agentes inmobiliarios a fijar el precio de los
nuevos apartamentos que ingresan al mercado. Además, los valores
previstos se pueden comparar con los precios del mercado para determinar
las oportunidades de compra de los apartamentos más infravalorados. Las
variables de entrada requeridas para este problema probablemente
incluirían aspectos como:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ciudad&lt;/strong&gt;: Ubicación del apartamento por ciudad.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Habitaciones&lt;/strong&gt;: Número de habitaciones del
apartamento.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tamaño&lt;/strong&gt;: Tamaño del apartamento por metros
cuadrados.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Como punto de partida, necesitamos un conjunto de datos con varios
ejemplos que contengan esta información:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-03-01-intro-ml/tab1.png" /&gt;&lt;/p&gt;
&lt;h3 id="aprendizaje-supervisado-objetivo"&gt;Aprendizaje supervisado:
objetivo&lt;/h3&gt;
&lt;p&gt;El objetivo del aprendizaje automático supervisado es tomar un
conjunto de ejemplos y entrenar un modelo utilizando métodos
estadísticos. Este modelo debe explicar la relación entre las variables
de entrada (por ejemplo, ciudad, habitaciones, tamaño) y la variable de
salida (por ejemplo, precio) con la mayor precisión posible. Una vez que
se ha entrenado el modelo, se puede utilizar para predecir el resultado
de nuevas combinaciones de valores de entrada invisibles.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-03-01-intro-ml/sup.png" /&gt;&lt;/p&gt;
&lt;h3 id="aprendizaje-no-supervisado"&gt;Aprendizaje no supervisado&lt;/h3&gt;
&lt;p&gt;Las técnicas de aprendizaje no supervisadas extraen estructuras y
patrones estadísticos de conjuntos de datos. A diferencia del
aprendizaje supervisado, estas técnicas no requieren una variable de
resultado predefinida en la que recibir entrenamiento.&lt;/p&gt;
&lt;p&gt;El método de aprendizaje no supervisado más importante es la
&lt;strong&gt;agrupación&lt;/strong&gt; o cluster. La agrupación intenta agrupar las
observaciones en función de su similitud. Primero, la similitud entre
las observaciones se calcula como una distancia entre sí. Basándonos en
estos valores, podemos determinar conglomerados (grupos) en los que las
observaciones están más próximas entre sí.&lt;/p&gt;
&lt;h4 id="aprendizaje-no-supervisado-ejemplo"&gt;Aprendizaje no supervisado:
ejemplo&lt;/h4&gt;
&lt;p&gt;Los métodos de agrupación en clústeres se aplican a menudo como un
intento de definir grupos de clientes que son similares. La similitud
puede significar intereses coincidentes, datos demográficos, ubicación
geográfica, etc. Esta aplicación se denomina segmentación de mercado. El
objetivo de este caso de uso es comprender mejor la base de clientes y
sus necesidades. Los clústeres se pueden utilizar para proporcionar
anuncios y ofertas dirigidos a los clientes de acuerdo con sus
propiedades. Como ejemplo, echemos un vistazo al siguiente gráfico:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-03-01-intro-ml/cluster.png" /&gt;&lt;/p&gt;
&lt;p&gt;Esta gráfica compara el &lt;code&gt;Annual Income&lt;/code&gt; y
&lt;code&gt;Spending Score&lt;/code&gt; de algunos clientes de centros comerciales.
Al aplicar un algoritmo de agrupación en clústeres y definir cinco
grupos, podemos separar muy bien 5 tipos diferentes de clientes. Los
grupos clave en este ejemplo serían el grupo azul y rojo, que generan la
mayor cantidad de ingresos. Éstos definen dos tipos de clientes.
Mientras que el grupo azul contiene clientes con ingresos más bajos, el
grupo rojo contiene clientes con ingresos relativamente altos. Con base
en esta información, se podría adaptar la estrategia de marketing:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Los clientes del clúster azul podrían ser un grupo objetivo óptimo
para opciones atractivas de financiamiento y crédito.&lt;/li&gt;
&lt;li&gt;Los clientes del grupo rojo deben mantenerse como clientes el mayor
tiempo posible. En particular, debe evitarse que cambien a competidores.
Por lo tanto, podrían ser un grupo objetivo óptimo para recompensas y
ofertas basadas en la lealtad.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="aprendizaje-reforzado"&gt;Aprendizaje reforzado&lt;/h3&gt;
&lt;p&gt;En lugar de aprender de un conjunto de ejemplos, el aprendizaje por
refuerzo se basa en las recompensas acumulativas que recibe una entidad
virtual (a menudo denominada &lt;strong&gt;agente&lt;/strong&gt;) al actuar en un
entorno específico. El agente intenta maximizar las recompensas
acumulativas tomando decisiones. Estas decisiones se basan inicialmente
en prueba y error, sin embargo, el agente se ve recompensado al tomar
buenas decisiones y aprende de ellas. Del mismo modo, también existen
algunos costos asociados con las malas decisiones. Por lo tanto, al
crear el entorno de aprendizaje, definimos las reglas y las recompensas
(y los costos), pero dejamos que el agente descubra los mejores pasos y
tácticas.&lt;/p&gt;
&lt;h4 id="aprendizaje-por-refuerzo-ejemplo"&gt;Aprendizaje por refuerzo:
ejemplo&lt;/h4&gt;
&lt;p&gt;Un ejemplo común es un mundo de cuadrícula, en el que el agente puede
moverse de un campo a otro, excepto por posibles obstáculos o paredes, y
es recompensado por encontrar la meta. Inicialmente, cada paso se daría
al azar, pero después de suficientes intentos, el agente siempre iría en
la dirección que maximiza sus posibilidades de obtener una recompensa.
Cada paso también está asociado con un costo que reduce la recompensa
acumulada. Esto significa que, desde cualquier punto de partida o
posición, el agente aprendería el camino más corto hacia la recompensa
después de un tiempo.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-03-01-intro-ml/fs.png" /&gt;&lt;/p&gt;
&lt;h2
id="aprendizaje-supervisado-con-regresión-y-clasificación"&gt;Aprendizaje
supervisado con regresión y clasificación&lt;/h2&gt;
&lt;p&gt;En el aprendizaje automático supervisado, tomamos un conjunto de
observaciones con una variable de resultado conocida y entrenamos un
modelo que describe con precisión la relación entre las variables de
entrada y el resultado.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Saber qué predictores y variables de resultado son&lt;/li&gt;
&lt;li&gt;Diferenciar entre regresión y clasificación&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="aprendizaje-supervisado-datos-de-entrada"&gt;Aprendizaje
supervisado: datos de entrada&lt;/h3&gt;
&lt;p&gt;En el aprendizaje supervisado, entrenamos modelos en un conjunto de
datos para describir la relación entre un valor de interés (resultado)
utilizando un conjunto de valores de entrada conocidos. Por lo tanto,
nuestros datos de entrenamiento para construir el modelo deben incluir
todas las entradas requeridas, así como el resultado previsto en forma
tabular. La tabla consta de dos partes:&lt;/p&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;Los &lt;strong&gt;predictores&lt;/strong&gt; o variables de entrada, que se
utilizan para calcular la predicción (también conocida como matriz de
modelo).&lt;/li&gt;
&lt;li&gt;La variable de &lt;strong&gt;resultado&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-03-01-intro-ml/tab.png" /&gt;&lt;/p&gt;
&lt;h3 id="predictores"&gt;Predictores&lt;/h3&gt;
&lt;p&gt;Los &lt;strong&gt;predictores&lt;/strong&gt; son un conjunto de variables de
entrada (columnas) que se utilizan para explicar y predecir el
resultado. A menudo se les llama variables de &lt;em&gt;entrada&lt;/em&gt;,
&lt;em&gt;independientes&lt;/em&gt;, &lt;em&gt;explicativas&lt;/em&gt; o simplemente
&lt;em&gt;características&lt;/em&gt;. En el caso de los precios de los apartamentos,
podría pensar en la cantidad de habitaciones, metros cuadrados o el
nombre de la ciudad.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-03-01-intro-ml/tab1.png" /&gt;&lt;/p&gt;
&lt;h3 id="variable-de-resultado"&gt;Variable de resultado&lt;/h3&gt;
&lt;p&gt;La variable de resultado es un solo valor/columna que queremos
predecir. A menudo se la denomina &lt;em&gt;objetivo&lt;/em&gt;, &lt;em&gt;respuesta&lt;/em&gt;,
&lt;em&gt;variable dependiente&lt;/em&gt; o simplemente denominada
&lt;em&gt;etiqueta&lt;/em&gt;. Como ejemplo, podría pensar nuevamente en el precio
de un apartamento:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-03-01-intro-ml/tab1.png" /&gt;&lt;/p&gt;
&lt;h3 id="regresión-vs.-clasificación"&gt;Regresión vs. clasificación&lt;/h3&gt;
&lt;p&gt;Dentro del dominio de aprendizaje supervisado, diferenciamos entre
modelos de &lt;strong&gt;regresión&lt;/strong&gt; y de
&lt;strong&gt;clasificación&lt;/strong&gt;. El modelo específico con el que estamos
tratando depende del tipo de datos de la variable de resultado. Si la
variable a predecir es continua (como &lt;code&gt;numérica&lt;/code&gt;), hablamos
de un modelo de regresión. Si la variable es un &lt;code&gt;factor&lt;/code&gt;
categórico tenemos un problema de clasificación.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-03-01-intro-ml/reg.png" /&gt;&lt;/p&gt;
&lt;h4 id="ejemplo-de-regresión-vs.-clasificación"&gt;Ejemplo de regresión
vs. clasificación&lt;/h4&gt;
&lt;p&gt;Cuando queremos predecir el precio de un apartamento, la salida es un
valor &lt;code&gt;numérico&lt;/code&gt; (continuo), lo que significa que estamos
tratando con un modelo de regresión. Por otro lado, cuando el cliente de
correo electrónico clasifica un correo electrónico en &lt;em&gt;Primario&lt;/em&gt;,
&lt;em&gt;Social&lt;/em&gt; o &lt;em&gt;Promociones&lt;/em&gt;, el resultado es un
&lt;code&gt;factor&lt;/code&gt; (categórico) y necesitamos usar un modelo de
clasificación.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-03-01-intro-ml/RCE.png" /&gt;&lt;/p&gt;
&lt;p&gt;Todo el material descrito se encuentra en idioma ingles en la página
oficial de Quantargo.&lt;/p&gt;
&lt;pre class="r distill-force-highlighting-css"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      <distill:md5>deecfcbc89d458f78d58a83697605e50</distill:md5>
      <guid>https://franklinsantos.com/posts/2022-03-01-intro-ml</guid>
      <pubDate>Tue, 01 Mar 2022 00:00:00 +0000</pubDate>
      <media:content url="https://franklinsantos.com/posts/2022-03-01-intro-ml/int.png" medium="image" type="image/png" width="1248" height="937"/>
    </item>
    <item>
      <title>Visualización de datos con ggplot2</title>
      <dc:creator>Franklin Santos</dc:creator>
      <link>https://franklinsantos.com/posts/2022-02-03-ggplot</link>
      <description>


&lt;style&gt;
body {
text-align: justify}
&lt;/style&gt;
&lt;h1 id="visualización-de-datos-con-ggplot2"&gt;Visualización de datos con
ggplot2&lt;/h1&gt;
&lt;p&gt;Comprender los tipos de gráficos y los principios básicos de la
gramática de los gráficos. Cree sus primeras visualizaciones con el
paquete ggplot2 que incluye diagramas de dispersión, gráficos de líneas
y gráficos de barras.&lt;/p&gt;
&lt;h2 id="por-qué-es-importante-la-visualización-de-datos"&gt;Por qué es
importante la visualización de datos&lt;/h2&gt;
&lt;p&gt;La visualización de datos no solo es importante para comunicar los
resultados, sino también una técnica poderosa para el análisis
exploratorio de datos. Cada tipo de diagrama, como diagramas de
dispersión, gráficos de líneas, gráficos de barras e histogramas, tiene
su propio propósito y se puede aprovechar de una manera poderosa
utilizando el paquete &lt;strong&gt;ggplot2&lt;/strong&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Comprender los diferentes roles de la visualización de datos.&lt;/li&gt;
&lt;li&gt;Comprender los diferentes tipos de parcelas disponibles.&lt;/li&gt;
&lt;li&gt;Obtenga una descripción general del paquete
&lt;strong&gt;ggplot2&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-02-03-ggplot/geom.png" /&gt;&lt;/p&gt;
&lt;h3 id="introducción-a-la-visualización-de-datos"&gt;Introducción a la
visualización de datos&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Una imagen vale mas que mil palabras&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;La visualización de datos es la técnica más rápida y poderosa para
comprender información nueva y existente. Durante una fase de
exploración inicial, los científicos de datos intentan revelar las
características subyacentes de un conjunto de datos, como diferentes
distribuciones, correlaciones u otros patrones visibles. Este proceso
también se denomina &lt;em&gt;análisis exploratorio de datos&lt;/em&gt; (EDA) y
marca el punto de partida de cada proyecto de ciencia de datos.&lt;/p&gt;
&lt;p&gt;Los gráficos producidos durante la EDA muestran al científico de
datos las direcciones del viaje por delante. Los patrones revelados
pueden inspirar hipótesis sobre los procesos subyacentes, las
características del conjunto de datos que se extraerán o las técnicas de
modelado que se probarán. Por último, pero no menos importante, las
visualizaciones descubren valores atípicos y errores de datos de los que
el científico de datos debe ocuparse.&lt;/p&gt;
&lt;p&gt;El papel más importante de la visualización de datos es la
comunicación de los hallazgos de la ciencia de datos a colegas y
clientes a través de presentaciones, informes o paneles. El esfuerzo
utilizado para la EDA y las visualizaciones es un tiempo bien invertido,
ya que los resultados se pueden utilizar directamente para comunicar los
hallazgos.&lt;/p&gt;
&lt;h3 id="tipos-de-gráficas-disponibles"&gt;Tipos de gráficas
disponibles&lt;/h3&gt;
&lt;p&gt;Hay muchos tipos de gráficos disponibles que ayudan a comprender las
diferentes características y relaciones en el conjunto de datos.&lt;/p&gt;
&lt;p&gt;Durante la fase de análisis de datos exploratorios, normalmente
queremos detectar los patrones más obvios observando cada variable de
forma aislada o detectando relaciones de variables con otras. El tipo de
gráfico utilizado también está determinado por el tipo de datos de las
variables de entrada, como numéricas o categóricas.&lt;/p&gt;
&lt;h4 id="gráfico-de-dispersión"&gt;Gráfico de dispersión&lt;/h4&gt;
&lt;p&gt;Los gráficos de dispersión se utilizan para visualizar la relación
entre dos variables numéricas. La posición de cada punto representa el
valor de las variables en los ejes &lt;em&gt;x&lt;/em&gt; e &lt;em&gt;y&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-02-03-ggplot/scat.png" /&gt;&lt;/p&gt;
&lt;h4 id="gráficos-lineales"&gt;Gráficos lineales&lt;/h4&gt;
&lt;p&gt;Los gráficos de líneas se utilizan para visualizar la trayectoria de
una variable numérica contra otra que están conectadas a través de
líneas. Son muy adecuados si los valores solo cambian
&lt;strong&gt;continuamente&lt;/strong&gt;, como la temperatura con el tiempo.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-02-03-ggplot/unna.png" /&gt;&lt;/p&gt;
&lt;h4 id="gráficos-de-barras-e-histogramas"&gt;Gráficos de barras e
histogramas&lt;/h4&gt;
&lt;p&gt;Los gráficos de barras visualizan valores &lt;code&gt;numéricos&lt;/code&gt;
agrupados por categorías. Cada categoría está representada por una barra
con una altura definida por cada valor &lt;code&gt;numérico&lt;/code&gt;. Los
histogramas son gráficos de barras específicos para resumir el número de
apariciones de valores numéricos en un conjunto de rangos de valores (o
bins). Suelen utilizarse para determinar la &lt;em&gt;distribución&lt;/em&gt; de
valores numéricos.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-02-03-ggplot/hist.png" /&gt;&lt;/p&gt;
&lt;h4 id="otros"&gt;Otros&lt;/h4&gt;
&lt;p&gt;Otros tipos de gráficos de uso frecuente en la ciencia de datos
incluyen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Diagramas de caja&lt;/strong&gt;: Muestra información de
distribución de valores numéricos agrupados en categorías como cajas.
Genial para comparar rápidamente múltiples distribuciones.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gráficos de violín&lt;/strong&gt;: igual que los gráficos de caja,
pero muestran distribuciones como &lt;em&gt;violines&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mapas de calor&lt;/strong&gt;: muestran las interacciones de las
variables, generalmente correlaciones, como imágenes rasterizadas que
resaltan áreas de alta interacción.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gráficos de red&lt;/strong&gt;: muestra conexiones entre
nodos&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-02-03-ggplot/otr.png" /&gt;&lt;/p&gt;
&lt;h3 id="presentamos-ggplot2"&gt;Presentamos: ggplot2&lt;/h3&gt;
&lt;p&gt;Debido a la importancia de la visualización para la ciencia de datos
y las estadísticas, R ofrece un amplio conjunto de herramientas y
paquetes. El lenguaje R básico ya proporciona un rico conjunto de
funciones de trazado y tipos de trazado. Estas funciones de trazado
requieren que los usuarios especifiquen cómo trazar cada elemento en el
lienzo paso a paso. Por el contrario, el paquete
&lt;strong&gt;ggplot2&lt;/strong&gt; permite la especificación de trazados a través
de un conjunto de &lt;em&gt;capas&lt;/em&gt; de trazado. Esto requiere que el
paquete averigüe los pasos necesarios para producir el gráfico.&lt;/p&gt;
&lt;p&gt;A través del conjunto predefinido de capas geométricas, facetas y
temas, &lt;strong&gt;ggplot2&lt;/strong&gt; permite a los usuarios crear hermosos
gráficos en muy poco tiempo. &lt;strong&gt;ggplot2&lt;/strong&gt; es también la
biblioteca de trazado más adoptada en la comunidad R.&lt;/p&gt;
&lt;h2 id="crea-un-diagrama-de-dispersión-con-ggplot"&gt;Crea un diagrama de
dispersión con ggplot&lt;/h2&gt;
&lt;p&gt;Realice sus primeros pasos con el paquete &lt;strong&gt;ggplot2&lt;/strong&gt;
para crear un diagrama de dispersión. Utilice la gramática de los
gráficos para asignar los atributos del conjunto de datos a su gráfico y
conectar diferentes capas con el operador &lt;code&gt;+&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Defina un conjunto de datos para la gráfica usando la función
&lt;code&gt;ggplot()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Especifique una capa geométrica usando la función
&lt;code&gt;geom_point()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Asigne los atributos del conjunto de datos a las propiedades de
trazado usando el parámetro de &lt;code&gt;mapping&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Conectar diferentes objetos &lt;code&gt;ggplot&lt;/code&gt; usando el operador
&lt;code&gt;+&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="r"&gt;&lt;code&gt;library(ggplot2)
ggplot(___) + 
  geom_point(
    mapping = aes(x = ___, y = ___)
  )&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="introducción-a-los-gráficos-de-dispersión"&gt;Introducción a los
gráficos de dispersión&lt;/h3&gt;
&lt;p&gt;Los diagramas de dispersión utilizan puntos para visualizar la
relación entre dos variables numéricas. La posición de cada punto
representa el valor de las variables en los ejes X e Y. Veamos un
ejemplo de un diagrama de dispersión para comprender la relación entre
la &lt;em&gt;speed&lt;/em&gt; y la &lt;em&gt;distancia de frenado&lt;/em&gt; de los
automóviles:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-02-03-ggplot/scat1.png" /&gt;&lt;/p&gt;
&lt;p&gt;Cada punto representa un automóvil. Cada automóvil comienza a frenar
a una velocidad dada en el eje-y y recorre la distancia que se muestra
en el eje-x hasta detenerse por completo. Si echamos un vistazo a todos
los puntos de la trama, podemos ver claramente que los coches más
rápidos necesitan más distancia para detenerse por completo.&lt;/p&gt;
&lt;h3 id="especificar-un-conjunto-de-datos"&gt;Especificar un conjunto de
datos&lt;/h3&gt;
&lt;p&gt;Para crear gráficos con &lt;strong&gt;ggplot2&lt;/strong&gt;, primero debe cargar
el paquete usando la &lt;code&gt;library(ggplot2)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Una vez que se haya cargado el paquete, especifique el conjunto de
datos que se utilizará como argumento de la función
&lt;code&gt;ggplot()&lt;/code&gt;. Por ejemplo, para especificar una gráfica usando
el conjunto de datos de &lt;code&gt;cars&lt;/code&gt;, puede usar:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;library(ggplot2)
library(gapminder)
ggplot(cars)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="file8c174445f26_files/figure-html/unnamed-chunk-2-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;Tenga en cuenta que este comando no traza nada más que un lienzo gris
todavía. Simplemente define el conjunto de datos para el gráfico y crea
una base vacía sobre la cual podemos agregar capas adicionales.&lt;/p&gt;
&lt;h3 id="especificando-una-capa-geométrica"&gt;Especificando una capa
geométrica&lt;/h3&gt;
&lt;p&gt;Podemos usar las capas geométricas de &lt;strong&gt;ggplot&lt;/strong&gt; (o
&lt;em&gt;geoms&lt;/em&gt;) para definir cómo queremos visualizar nuestro conjunto
de datos. Las &lt;em&gt;geoms&lt;/em&gt; utilizan objetos geométricos para
visualizar las variables de un conjunto de datos. Los objetos pueden
tener múltiples formas como puntos, líneas y barras y se especifican
mediante las funciones correspondientes &lt;code&gt;geom_point()&lt;/code&gt;,
&lt;code&gt;geom_line()&lt;/code&gt; y &lt;code&gt;geom_col()&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-02-03-ggplot/geom.png" /&gt;&lt;/p&gt;
&lt;h3 id="creando-mapeos-estéticos"&gt;Creando mapeos estéticos&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ggplot2&lt;/strong&gt; utiliza el concepto de &lt;em&gt;estética&lt;/em&gt;,
que &lt;em&gt;asigna&lt;/em&gt; los atributos del conjunto de datos a las
características visuales de la gráfica. Cada capa geométrica requiere un
conjunto diferente de &lt;em&gt;asignaciones estéticas&lt;/em&gt;, p. Ej. la función
&lt;code&gt;geom_point()&lt;/code&gt; usa la estética &lt;code&gt;x&lt;/code&gt; e
&lt;code&gt;y&lt;/code&gt; para determinar las coordenadas de los ejes
&lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; de los puntos a graficar. La estética se
asigna dentro de la función &lt;code&gt;aes()&lt;/code&gt; para construir las
asignaciones finales.&lt;/p&gt;
&lt;p&gt;Para especificar una capa de puntos que traza la velocidad variable
en el eje-x y la distancia &lt;code&gt;dist&lt;/code&gt; en el eje-y, podemos
escribir:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;geom_point(
  mapping = aes(x=speed, y=dist)
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La expresión anterior construye una capa geométrica. Sin embargo,
esta capa actualmente no está vinculada a un conjunto de datos y no
produce una gráfica. Para &lt;strong&gt;vincular&lt;/strong&gt; la capa con un
objeto &lt;code&gt;ggplot&lt;/code&gt; que especifica el conjunto de datos de
&lt;code&gt;cars&lt;/code&gt;, necesitamos conectar el objeto
&lt;code&gt;ggplot(cars)&lt;/code&gt; con la capa &lt;code&gt;geom_point()&lt;/code&gt; usando
el operador &lt;code&gt;+&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;ggplot(cars) + 
  geom_point(
    mapping = aes(x=speed, y=dist)
  )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="file8c174445f26_files/figure-html/unnamed-chunk-4-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;A través del enlace, &lt;code&gt;ggplot()&lt;/code&gt; sabe que las variables de
&lt;code&gt;speed&lt;/code&gt; y &lt;code&gt;dist&lt;/code&gt; asignadas se toman del conjunto
de datos de &lt;code&gt;cars&lt;/code&gt;. &lt;code&gt;geom_point()&lt;/code&gt; instruye a
ggplot para trazar las variables mapeadas como puntos.&lt;/p&gt;
&lt;p&gt;Los pasos necesarios para crear un diagrama de dispersión con
&lt;code&gt;ggplot&lt;/code&gt; se pueden resumir de la siguiente manera:&lt;/p&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;Cargue el paquete &lt;strong&gt;ggplot2&lt;/strong&gt; usando
&lt;code&gt;library(ggplot2)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Especifique el conjunto de datos que se graficará usando
&lt;code&gt;ggplot()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Utilice el operador &lt;code&gt;+&lt;/code&gt; para agregar capas al
gráfico.&lt;/li&gt;
&lt;li&gt;Agregue una capa geométrica para definir las formas que se
graficaran. En caso de gráficos de dispersión, use
&lt;code&gt;geom_point()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Asigne variables del conjunto de datos a propiedades de trazado a
través del parámetro de &lt;code&gt;mapping&lt;/code&gt; en la capa geométrica.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="especificar-estética-adicional-para-puntos"&gt;Especificar estética
adicional para puntos&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ggplot2&lt;/strong&gt; implementa la gramática de gráficos para
mapear atributos de un conjunto de datos para trazar características a
través de la estética. Este marco se puede utilizar para ajustar el
&lt;code&gt;tamaño de punto&lt;/code&gt;, el &lt;code&gt;color&lt;/code&gt; y la transparencia
&lt;code&gt;alpha&lt;/code&gt; de los puntos en un diagrama de dispersión.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Agregue dimensiones de trazado adicionales a través de la
estética&lt;/li&gt;
&lt;li&gt;Ajuste el tamaño del punto de un gráfico de dispersión usando el
parámetro &lt;code&gt;size&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Cambiar el color del punto de un diagrama de dispersión usando el
parámetro &lt;code&gt;color&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Establecer un parámetro &lt;code&gt;alpha&lt;/code&gt; para cambiar la
transparencia de todos los puntos&lt;/li&gt;
&lt;li&gt;Diferenciar entre mapeos estéticos y parámetros constantes&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="r"&gt;&lt;code&gt;ggplot(___) + 
  geom_point(
    mapping = aes(x = ___, y = ___, 
                  color = ___, 
                  size  = ___),
    alpha  = ___
  )&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="añadiendo-más-estética-a-la-trama"&gt;Añadiendo más estética a la
trama&lt;/h3&gt;
&lt;p&gt;En su forma más básica, los diagramas de dispersión solo pueden
visualizar conjuntos de datos en dos dimensiones a través de la estética
&lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; de la capa &lt;code&gt;geom_point()&lt;/code&gt;.
Sin embargo, la mayoría de los conjuntos de datos tienen más de dos
variables y, por lo tanto, pueden requerir dimensiones de trazado
adicionales. &lt;code&gt;ggplot()&lt;/code&gt; hace que sea muy fácil mapear
variables adicionales a diferentes estéticas de trazado como
&lt;code&gt;size&lt;/code&gt;, transparencia &lt;code&gt;alpha&lt;/code&gt; y
&lt;code&gt;color&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Consideremos el conjunto de datos &lt;code&gt;gapminder_2007&lt;/code&gt; que
contiene las variables PIB per cápita &lt;code&gt;gdpPercap&lt;/code&gt; y esperanza
de vida &lt;code&gt;lifeExp&lt;/code&gt; para 142 países en el año 2007:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;library(tidyverse)
library(gapminder)
## select data
gapminder_2007 &amp;lt;- gapminder%&amp;gt;%
  filter(year == 2007)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;ggplot(gapminder_2007) + 
  geom_point(aes(x = gdpPercap, y = lifeExp))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="file8c174445f26_files/figure-html/unnamed-chunk-7-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;Al mapear la variable &lt;code&gt;continent&lt;/code&gt; a través de la estética
del &lt;code&gt;color&lt;/code&gt; del punto y la población &lt;code&gt;pop&lt;/code&gt; (en
millones) a través del tamaño del punto &lt;code&gt;size&lt;/code&gt;, obtenemos una
gráfica mucho más rica que incluye 4 variables diferentes del conjunto
de datos:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-02-03-ggplot/un4.png" /&gt;&lt;/p&gt;
&lt;h3 id="ajuste-del-color-del-punto"&gt;Ajuste del color del punto&lt;/h3&gt;
&lt;p&gt;Normalmente, el color del punto se utiliza para introducir una nueva
dimensión en un diagrama de dispersión. En ggplot usamos la estética del
&lt;code&gt;color&lt;/code&gt; para especificar el mapeo de una variable al color de
los puntos.&lt;/p&gt;
&lt;p&gt;Para el conjunto de datos &lt;code&gt;gapminder_2007&lt;/code&gt; podemos trazar
el PIB per cápita &lt;code&gt;gdpPercap&lt;/code&gt; frente a la esperanza de vida
&lt;code&gt;lifeExp&lt;/code&gt; de la siguiente manera:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;ggplot(gapminder_2007) + 
  geom_point(aes(x = gdpPercap, y = lifeExp))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="file8c174445f26_files/figure-html/unnamed-chunk-8-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;Para colorear cada punto en función del &lt;code&gt;continent&lt;/code&gt; de
cada país podemos utilizar:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;ggplot(gapminder_2007) + 
  geom_point(aes(x = gdpPercap, y = lifeExp,
                 color = continent))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="file8c174445f26_files/figure-html/unnamed-chunk-9-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;Vemos que en la trama resultante cada punto está coloreado de manera
diferente según el &lt;code&gt;continent&lt;/code&gt; de cada país.
&lt;code&gt;ggplot&lt;/code&gt; usa el esquema de coloración basado en el tipo de
datos categóricos de la variable &lt;code&gt;continent&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Por el contrario, veamos cómo se ve el gráfico si coloreamos los
puntos por el &lt;code&gt;pop&lt;/code&gt; de población de la variable
&lt;code&gt;numeric&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;ggplot(gapminder_2007) + 
  geom_point(aes(x = gdpPercap, y = lifeExp,
                 color = pop))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="file8c174445f26_files/figure-html/unnamed-chunk-10-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;La escala cambia inmediatamente a continua como se puede ver en la
leyenda y los puntos celestes son ahora los países con mayor número de
población (China e India).&lt;/p&gt;
&lt;h3 id="ajustar-el-tamaño-del-punto"&gt;Ajustar el tamaño del punto&lt;/h3&gt;
&lt;p&gt;Para el conjunto de datos de &lt;code&gt;gapminder_2007&lt;/code&gt; podemos
trazar el PIB per cápita &lt;code&gt;gdpPercap&lt;/code&gt; frente a la esperanza de
vida de la siguiente manera:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;ggplot(gapminder_2007) + 
  geom_point(aes(x = gdpPercap, 
                 y = lifeExp))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="file8c174445f26_files/figure-html/unnamed-chunk-11-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;Para ajustar el tamaño de puntos en función de la población
(&lt;code&gt;pop&lt;/code&gt;) de cada país, podemos usar:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;ggplot(gapminder_2007) + 
  geom_point(aes(x = gdpPercap, y = lifeExp,
                 size = pop))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="file8c174445f26_files/figure-html/unnamed-chunk-12-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;Vemos que los tamaños de puntos en el gráfico anterior no reflejan
claramente las diferencias de población en cada país. Si comparamos el
tamaño en puntos que representa una población de 250 millones de
personas con el que muestra 750 millones, podemos ver que sus tamaños no
son proporcionales. En su lugar, los tamaños en puntos están agrupados
de forma predeterminada. Para reflejar las diferencias de población
reales por el tamaño de puntos, podemos usar la función
&lt;code&gt;scale_size_area()&lt;/code&gt; en su lugar. La información de escala se
puede agregar como cualquier otro objeto ggplot con el operador
&lt;code&gt;+&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;ggplot(gapminder_2007) + 
  geom_point(aes(x = gdpPercap, y = lifeExp,
                 color = continent,
                 size = pop)) + 
  scale_size_area(max_size = 10)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="file8c174445f26_files/figure-html/unnamed-chunk-13-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;Tenga en cuenta que hemos ajustado el tamaño del punto con
&lt;code&gt;max_size&lt;/code&gt;, lo que da como resultado tamaños de punto más
grandes.&lt;/p&gt;
&lt;h3 id="establecer-la-estética-global-transparencia"&gt;Establecer la
estética global: transparencia&lt;/h3&gt;
&lt;p&gt;Trazar muchos puntos con coordenadas X e Y similares en un gráfico
puede producir nubes de puntos densas. Muchos puntos en estas nubes
están sobretrazados y el número real de observaciones en un área
determinada ya no es visible. Como solución, podemos establecer la
transparencia de cada punto usando el parámetro ggplot
&lt;code&gt;alpha&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Dado que &lt;strong&gt;no&lt;/strong&gt; queremos establecer la transparencia del
punto &lt;strong&gt;individualmente&lt;/strong&gt; para cada punto sino
&lt;strong&gt;globalmente&lt;/strong&gt; para todos los puntos, no establecemos el
parámetro &lt;code&gt;alpha&lt;/code&gt; como un mapeo estético (dentro de
&lt;code&gt;aes()&lt;/code&gt;) sino fuera.&lt;/p&gt;
&lt;p&gt;Establecemos la &lt;strong&gt;opacidad&lt;/strong&gt; de cada punto al 50% a
través del parámetro &lt;code&gt;alpha&lt;/code&gt; &lt;strong&gt;outside&lt;/strong&gt; como
parámetro constante:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;ggplot(gapminder_2007) + 
  geom_point(aes(x = gdpPercap, y = lifeExp, size = pop), 
             alpha = 0.5)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="file8c174445f26_files/figure-html/unnamed-chunk-14-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;Ahora podemos ver claramente cuántos puntos se superponen entre sí y
la opacidad de cada punto se establece en &lt;code&gt;0.5&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="crea-un-gráfico-de-líneas-con-ggplot"&gt;Crea un gráfico de líneas
con ggplot&lt;/h2&gt;
&lt;p&gt;Use la estética &lt;code&gt;geom_line()&lt;/code&gt; para dibujar gráficos de
líneas y personalizar su estilo usando el parámetro &lt;code&gt;color&lt;/code&gt;.
Especifique qué coordenadas usar para cada línea con el parámetro
&lt;code&gt;group&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Crea tu primer gráfico de línea usando &lt;code&gt;geom_line()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Defina cómo se conectan las diferentes líneas mediante el parámetro
&lt;code&gt;group&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Cambiar el color de línea de un gráfico de líneas usando el
parámetro &lt;code&gt;color&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="r"&gt;&lt;code&gt;ggplot(___) + 
  geom_line(
    mapping = aes(x = ___, y = ___, 
                  group = ___, 
                  color = ___)
)&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="introducción-a-los-gráficos-lineales"&gt;Introducción a los
gráficos lineales&lt;/h3&gt;
&lt;p&gt;Los gráficos de líneas se utilizan para visualizar la trayectoria de
una variable numérica contra otra. A diferencia de los diagramas de
dispersión, las coordenadas &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; no se
visualizan a través de puntos, sino que están conectadas a través de
líneas. Los gráficos de líneas se utilizan con mayor frecuencia si una
variable cambia &lt;em&gt;continuamente&lt;/em&gt; contra otra variable numérica,
como es el caso de la mayoría de los gráficos de series de tiempo (por
ejemplo, precios, clientes, concentración de CO2, temperatura a lo largo
del tiempo), funciones continuas (por ejemplo, sinusoidal (x)) u otras
relaciones casi continuas (curvas de oferta/demanda del mundo real).&lt;/p&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-02-03-ggplot/geo1.png" /&gt;&lt;/p&gt;
&lt;h3 id="crear-un-gráfico-lineal-simple"&gt;Crear un gráfico lineal
simple&lt;/h3&gt;
&lt;p&gt;Japón se encuentra entre los países con mayor esperanza de vida.
Utilizando el conjunto de datos &lt;code&gt;gapminder_japan&lt;/code&gt;,
determinamos cómo se ha desarrollado la esperanza de vida en Japón a lo
largo del tiempo. Necesitamos que:&lt;/p&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;Especifique el conjunto de datos dentro de
&lt;code&gt;ggplot()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Definir la capa de trazado &lt;code&gt;geom_line()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Asigne el &lt;code&gt;year&lt;/code&gt; al eje x y la esperanza de vida
&lt;code&gt;lifeExp&lt;/code&gt; al eje y con la función &lt;code&gt;aes()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Tenga en cuenta que la biblioteca &lt;strong&gt;ggplot2&lt;/strong&gt; debe
cargarse primero con &lt;code&gt;library(ggplot2)&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;library(ggplot2)
gapminder_japan &amp;lt;- gapminder %&amp;gt;%
  filter(country == &amp;quot;Japan&amp;quot;)
## gráfica
ggplot(gapminder_japan) + 
  geom_line(
    mapping = aes(x = year, y = lifeExp)
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="file8c174445f26_files/figure-html/unnamed-chunk-16-1.png" width="672" /&gt;&lt;/p&gt;
&lt;h3 id="agregar-más-líneas"&gt;Agregar más líneas&lt;/h3&gt;
&lt;p&gt;Hasta ahora solo nos hemos centrado en líneas simples, pero ¿qué pasa
si tenemos varios países en el conjunto de datos y queremos
diferenciarlos de alguna manera?&lt;/p&gt;
&lt;p&gt;Los gráficos de líneas a menudo se amplían y se utilizan para
comparar dos o más líneas. Los gráficos de líneas múltiples muestran las
diferencias absolutas entre las observaciones, pero también cómo las
trayectorias específicas se relacionan entre sí. Por ejemplo,
respondamos a la pregunta: &lt;em&gt;¿Cómo ha cambiado la esperanza de vida en
los países Austria y Hungría a lo largo del tiempo?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Primero filtramos el conjunto de datos para ambos países de interés.
Luego, establecemos la variable &lt;code&gt;country&lt;/code&gt; como argumento de
&lt;code&gt;group&lt;/code&gt; para el mapeo estético. El argumento de grupo le dice
a ggplot qué observaciones pertenecen juntas y deben conectarse a través
de líneas. Al especificar la variable &lt;code&gt;country&lt;/code&gt;, ggplot crea
una línea separada para cada país. Para que las líneas sean más fáciles
de distinguir, también asignamos &lt;code&gt;color&lt;/code&gt; a
&lt;code&gt;country&lt;/code&gt; para que cada línea de país tenga un color
diferente.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;gapminder_comparison &amp;lt;- 
  filter(gapminder, country %in% c(&amp;quot;Austria&amp;quot;, &amp;quot;Hungary&amp;quot;))

ggplot(data = gapminder_comparison) + 
  geom_line(mapping = aes(x = year, y = lifeExp, 
                          group = country, 
                          color = country)
            )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="file8c174445f26_files/figure-html/unnamed-chunk-17-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;Tenga en cuenta que ggplot también separa las líneas correctamente si
solo se especifica la asignación &lt;code&gt;color&lt;/code&gt; (el parámetro
&lt;code&gt;group&lt;/code&gt; se establece implícitamente).&lt;/p&gt;
&lt;h2 id="crea-tu-primer-gráfico-de-barras"&gt;Crea tu primer gráfico de
barras&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Crea tu primer gráfico de barras usando &lt;code&gt;geom_col()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Rellenar barras con color usando la estética &lt;code&gt;fill&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="r"&gt;&lt;code&gt;ggplot(___) + 
  geom_col(
    mapping = aes(x = ___, y = ___, 
                  fill = ___)
 )&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="introducción-a-los-gráficos-de-barras"&gt;Introducción a los
gráficos de barras&lt;/h3&gt;
&lt;p&gt;Los gráficos de barras visualizan valores &lt;code&gt;numéricos&lt;/code&gt;
agrupados por categorías. Cada categoría está representada por una barra
con una altura definida por cada valor &lt;code&gt;numérico&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Los gráficos de barras son adecuados para comparar valores entre
diferentes grupos, p. Ej. número de votos por partidos, número de
personas en diferentes países o PIB per cápita en diferentes países. Los
gráficos de barras son un poco espaciosos y funcionan mejor si el número
de grupos a comparar es bastante pequeño.&lt;/p&gt;
&lt;p&gt;A continuación, puede encontrar un ejemplo que muestra la cantidad de
personas (en millones) en los cinco países más grandes por población en
2007:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://franklinsantos.com/posts/2022-02-03-ggplot/bar1.png" /&gt;&lt;/p&gt;
&lt;h3 id="crear-un-gráfico-de-barras-simple"&gt;Crear un gráfico de barras
simple&lt;/h3&gt;
&lt;p&gt;En &lt;strong&gt;ggplot2&lt;/strong&gt;, los gráficos de barras se crean
utilizando la capa geométrica &lt;code&gt;geom_col()&lt;/code&gt;. La capa
&lt;code&gt;geom_col()&lt;/code&gt; requiere el mapeo estético &lt;code&gt;x&lt;/code&gt; que
define las diferentes barras a trazar. La altura de cada barra está
definida por la variable especificada en el mapeo estético
&lt;code&gt;y&lt;/code&gt;. Ambas asignaciones, &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt;, son
necesarias para &lt;code&gt;geom_col()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Creemos nuestro primer gráfico de barras con el conjunto de datos
&lt;code&gt;gapminder_top5&lt;/code&gt;. Contiene datos de población (en millones) y
esperanza de vida de los países más grandes por población en 2007.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;gapminder_top5 &amp;lt;- gapminder %&amp;gt;%
  filter(year == 2007) %&amp;gt;%
  slice_max(pop, n=5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;ggplot(gapminder_top5) + 
  geom_col(aes(x = country, y = pop))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="file8c174445f26_files/figure-html/unnamed-chunk-20-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;Vemos que las barras resultantes están ordenadas por los nombres de
los países en orden alfabético por defecto.&lt;/p&gt;
&lt;h3 id="llenado-de-barras-de-color"&gt;Llenado de barras de color&lt;/h3&gt;
&lt;p&gt;Al igual que otras geoms, &lt;code&gt;geom_col()&lt;/code&gt; permite a los
usuarios asignar variables de conjuntos de datos adicionales al atributo
de color de la barra. La estética &lt;code&gt;fill&lt;/code&gt; se puede utilizar
para llenar de color todas las barras. Una confusión habitual es la
estética &lt;code&gt;color&lt;/code&gt; que especifica el color de la &lt;em&gt;línea&lt;/em&gt;
del borde de cada barra en lugar del color &lt;code&gt;fill&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Según el conjunto de datos &lt;code&gt;gapminder_top5&lt;/code&gt;, trazamos la
población (en millones) de los países más grandes y usamos la variable
&lt;code&gt;continent&lt;/code&gt; para colorear cada barra:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;ggplot(gapminder_top5) + 
  geom_col(aes(x = country, y = pop, fill = continent))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="file8c174445f26_files/figure-html/unnamed-chunk-21-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;Dado que la variable &lt;code&gt;continent&lt;/code&gt; es una variable
categórica, las barras tienen un esquema de color claro para cada
continente. Veamos qué sucede si usamos una variable
&lt;code&gt;numérica&lt;/code&gt; como la esperanza de vida &lt;code&gt;lifeExp&lt;/code&gt; en
su lugar:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;ggplot(gapminder_top5) + 
  geom_col(aes(x = country, y = pop, fill = lifeExp))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="file8c174445f26_files/figure-html/unnamed-chunk-22-1.png" width="672" /&gt;&lt;/p&gt;
&lt;p&gt;Los colores de las barras ahora han cambiado según la leyenda
&lt;strong&gt;continua&lt;/strong&gt; de la derecha. Vemos que también se pueden
utilizar variables &lt;code&gt;numéricas&lt;/code&gt; para &lt;code&gt;rellenar&lt;/code&gt;
barras.&lt;/p&gt;
&lt;h3 id="gráficos-de-barras-apiladas"&gt;Gráficos de barras apiladas&lt;/h3&gt;
&lt;p&gt;En algunas circunstancias, puede resultar útil trazar múltiples
variables de valores numéricos dentro de cada barra. Los ejemplos son
valores numéricos que describen una entidad específica (por ejemplo,
clientes) dividida entre varias categorías (segmentos de clientes) de
modo que la altura de la barra representa el número total (todos los
clientes).&lt;/p&gt;
&lt;p&gt;El siguiente gráfico muestra la cantidad de teléfonos (en miles) por
continente desde 1956 hasta 1961 como un gráfico de barras apiladas:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;## Ordenando la base de dato
world_phones &amp;lt;- WorldPhones %&amp;gt;%
  as.data.frame() %&amp;gt;%
  rownames_to_column(&amp;quot;Year&amp;quot;) %&amp;gt;%
  pivot_longer(cols=-Year, names_to=&amp;quot;region&amp;quot;, values_to=&amp;quot;phones&amp;quot;) %&amp;gt;%
  filter(Year &amp;gt;1955)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;ggplot(world_phones) + 
  geom_col(aes(x = Year, y = phones,
               fill = region))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="file8c174445f26_files/figure-html/unnamed-chunk-24-1.png" width="672" /&gt;&lt;/p&gt;
&lt;pre class="r distill-force-highlighting-css"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      <distill:md5>78ff4a499eb63cb948088988da1f1194</distill:md5>
      <category>ggplot2</category>
      <category>Data Science</category>
      <category>Data Visualization</category>
      <guid>https://franklinsantos.com/posts/2022-02-03-ggplot</guid>
      <pubDate>Thu, 03 Feb 2022 00:00:00 +0000</pubDate>
      <media:content url="https://franklinsantos.com/posts/2022-02-03-ggplot/logo.png" medium="image" type="image/png" width="240" height="278"/>
    </item>
    <item>
      <title>Transformación de datos con dplyr</title>
      <dc:creator>Franklin Santos</dc:creator>
      <link>https://franklinsantos.com/posts/2022-01-10-diplyr</link>
      <description>


&lt;style&gt;
body {
text-align: justify}
&lt;/style&gt;
&lt;h2 id="introducción-a-dplyr"&gt;Introducción a dplyr&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;dplyr&lt;/strong&gt; facilita el proceso de transformación de datos
al proporcionar un marco enriquecido para manipular marcos de datos. Las
funciones de &lt;strong&gt;dplyr&lt;/strong&gt; se pueden concatenar a potentes
canalizaciones de transformación para &lt;em&gt;seleccionar&lt;/em&gt;,
&lt;em&gt;filtrar&lt;/em&gt;, &lt;em&gt;ordenar&lt;/em&gt;, &lt;em&gt;unir&lt;/em&gt; y &lt;em&gt;agregar&lt;/em&gt;
datos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Descubra lo que hace &lt;strong&gt;dplyr&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Obtenga una descripción general de Seleccionar, Filtrar y
Ordenar&lt;/li&gt;
&lt;li&gt;Descubra qué son las uniones, agregaciones y canalizaciones&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="qué-es-dplyr"&gt;¿Qué es dplyr?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Existe la broma de que el 80 % de la ciencia de datos está limpiando
los datos y el 20 % se queja de limpiar los datos. — Anthony Goldbloom,
fundador y CEO de Kaggle&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Tener datos &lt;em&gt;limpios&lt;/em&gt; en cualquier proyecto de Data Science es
muy importante, porque los resultados solo son tan buenos como los datos
correctos. La limpieza de datos también es la parte que generalmente
consume la mayor parte del tiempo y causa los mayores dolores para los
científicos de datos. R ya ofrece un amplio conjunto de herramientas y
funciones para manipular marcos de datos. Sin embargo, debido a su larga
historia, el conjunto de herramientas base R disponible está fragmentado
y es difícil de usar para nuevos usuarios.&lt;/p&gt;
&lt;p&gt;El paquete &lt;strong&gt;dplyr&lt;/strong&gt; facilita el proceso de
transformación de datos a través de una colección consistente de
funciones. Estas funciones admiten diferentes transformaciones en marcos
de datos, que incluyen&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;filtrar filas&lt;/li&gt;
&lt;li&gt;seleccionar columnas&lt;/li&gt;
&lt;li&gt;ordenar datos&lt;/li&gt;
&lt;li&gt;agregar datos&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Múltiples marcos de datos también se pueden unir mediante valores de
atributo comunes.&lt;/p&gt;
&lt;p&gt;La coherencia de las funciones de &lt;strong&gt;dplyr&lt;/strong&gt; mejora la
usabilidad y permite al usuario conectar transformaciones para formar
&lt;em&gt;canalizaciones de datos&lt;/em&gt;. Estas canalizaciones también se pueden
ver como un lenguaje de consulta de alto nivel, como p. Ej. el lenguaje
SQL para consultas de bases de datos. Además, incluso es posible
traducir las canalizaciones de datos creadas a otros back-end, incluidas
las bases de datos.&lt;/p&gt;
&lt;h3 id="marco-de-funciones"&gt;Marco de funciones&lt;/h3&gt;
&lt;p&gt;Cada función de transformación de datos en &lt;strong&gt;dplyr&lt;/strong&gt;
acepta un marco de datos como su primer parámetro de entrada y devuelve
el marco de datos transformado como salida. Un plano para una función
&lt;strong&gt;dplyr&lt;/strong&gt; típica se ve así:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;transformed &amp;lt;- dplyr_function(my_data_frame, 
                              param_one, 
                              param_two, 
                              ...)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La función &lt;code&gt;dplyr_function&lt;/code&gt; se puede personalizar aún más
a través de argumentos adicionales (&lt;code&gt;param_one&lt;/code&gt;,
&lt;code&gt;param_two&lt;/code&gt;) colocados después del primer parámetro de marco
de datos (&lt;code&gt;my_data_frame&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;El poder real de &lt;strong&gt;dplyr&lt;/strong&gt; viene con el operador pipe
&lt;code&gt;%&amp;gt;%&lt;/code&gt; que permite a los usuarios concatenar funciones de
&lt;strong&gt;dplyr&lt;/strong&gt; a pipe de datos. Pipe inyecta el marco de datos
resultante del cálculo anterior como primer argumento del siguiente. Una
transformación de datos que consta de tres funciones se parece a:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;dplyr_function_three(
  dplyr_function_two(
    dplyr_function_one(input_data_frame)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pero con &lt;code&gt;pipe&lt;/code&gt; se puede escribir de la siguiente
manera:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;input_data_frame %&amp;gt;%
  dplyr_function_one() %&amp;gt;%
  dplyr_function_two() %&amp;gt;%
  dplyr_function_three()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El orden de lectura diferente de las funciones de transformación de
datos en el orden de transformación real, hace que las canalizaciones
sean más fáciles de leer que las llamadas a funciones anidadas.&lt;/p&gt;
&lt;h2 id="seleccionar-columnas-de-un-marco-de-datos"&gt;Seleccionar columnas
de un marco de datos&lt;/h2&gt;
&lt;p&gt;Para seleccionar sólo un conjunto específico de columnas de marcos de
datos interesantes, &lt;strong&gt;dplyr&lt;/strong&gt; ofrece la función
&lt;code&gt;select()&lt;/code&gt; para extraer columnas por nombres, índices y
rangos. Incluso puede renombrar las columnas extraídas con
&lt;code&gt;select()&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Aprenda a usar la función &lt;code&gt;select()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Seleccionar las columnas de un marco de datos por nombre o
índice&lt;/li&gt;
&lt;li&gt;Renombrar las columnas de un marco de datos&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="r"&gt;&lt;code&gt;select(my_data_frame, column_one, column_two, ...)
select(my_data_frame, new_column_name = current_column, ...)
select(my_data_frame, column_start:column_end)
select(my_data_frame, index_one, index_two, ...)
select(my_data_frame, index_start:index_end)&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="seleccionando-por-nombre"&gt;Seleccionando por nombre&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;select(my_data_frame, column_one, column_two, ...)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En este capítulo veremos el conjunto de datos
&lt;code&gt;pres_results&lt;/code&gt; del paquete &lt;strong&gt;politicaldata&lt;/strong&gt;.
Contiene datos sobre las elecciones presidenciales de EE.UU. desde 1976,
convertidas en un Tibble para una mejor impresión.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 561 × 6
    year state total_votes   dem   rep   other
   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;
 1  1976 AK         123574 0.357 0.579 0.0549 
 2  1976 AL        1182850 0.557 0.426 0.0163 
 3  1976 AR         767535 0.650 0.349 0.00134
 4  1976 AZ         742719 0.398 0.564 0.0383 
 5  1976 CA        7803770 0.480 0.497 0.0230 
 6  1976 CO        1081440 0.426 0.540 0.0336 
 7  1976 CT        1386355 0.467 0.519 0.0138 
 8  1976 DC         168830 0.816 0.165 0.0169 
 9  1976 DE         235642 0.520 0.466 0.0144 
10  1976 FL        3150631 0.519 0.466 0.0143 
# … with 551 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para este ejemplo, veremos el número total de votos en diferentes
estados en diferentes elecciones. Como solo estamos interesados en la
cantidad de personas que votaron, nos gustaría crear una versión
personalizada del marco de datos &lt;code&gt;pres_results&lt;/code&gt; que solo
contenga las columnas &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt; y
&lt;code&gt;total_votes&lt;/code&gt;. Para dicho filtrado, podemos usar la función
&lt;code&gt;select()&lt;/code&gt; del paquete &lt;strong&gt;dplyr&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;La función &lt;code&gt;select()&lt;/code&gt; toma un marco de datos como
parámetro de entrada y nos permite decidir cuál de las columnas queremos
mantener. El resultado de la función es un marco de datos con todas las
filas, pero que contiene solo las columnas que seleccionamos
explícitamente.&lt;/p&gt;
&lt;p&gt;Podemos reducir nuestro conjunto de datos a solo &lt;code&gt;year&lt;/code&gt;,
&lt;code&gt;state&lt;/code&gt; y &lt;code&gt;total_votes&lt;/code&gt; de la siguiente
manera:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;tibble(
select(pres_results, year, state, total_votes)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 561 × 3
    year state total_votes
   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;
 1  1976 AK         123574
 2  1976 AL        1182850
 3  1976 AR         767535
 4  1976 AZ         742719
 5  1976 CA        7803770
 6  1976 CO        1081440
 7  1976 CT        1386355
 8  1976 DC         168830
 9  1976 DE         235642
10  1976 FL        3150631
# … with 551 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como primer parámetro pasamos el marco de datos
&lt;code&gt;pres_results&lt;/code&gt;, como parámetros restantes pasamos las
columnas que queremos mantener para &lt;code&gt;select()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Además de mantener las columnas que queremos, la función
&lt;code&gt;select()&lt;/code&gt; también las mantiene en el mismo orden que
especificamos en los parámetros de la función.&lt;/p&gt;
&lt;p&gt;Si cambiamos el orden de los parámetros cuando llamamos a la función,
las columnas de la salida cambian en consecuencia:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;tibble(
select(pres_results, total_votes, year, state)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 561 × 3
   total_votes  year state
         &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;
 1      123574  1976 AK   
 2     1182850  1976 AL   
 3      767535  1976 AR   
 4      742719  1976 AZ   
 5     7803770  1976 CA   
 6     1081440  1976 CO   
 7     1386355  1976 CT   
 8      168830  1976 DC   
 9      235642  1976 DE   
10     3150631  1976 FL   
# … with 551 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="renombrar-nombres-de-columnas"&gt;Renombrar nombres de
columnas&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;select(my_data_frame, new_column_name = current_column, ...)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Además de definir las columnas que queremos conservar, también
podemos cambiarles el nombre. Para hacer esto, necesitamos establecer el
nuevo nombre de columna dentro de la función &lt;code&gt;select()&lt;/code&gt;
usando el comando&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;new_column_name = current_column&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En el siguiente ejemplo, seleccionamos las columnas
&lt;code&gt;year&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt; y &lt;code&gt;total_votes&lt;/code&gt; pero
cambiamos el nombre de la columna &lt;code&gt;year&lt;/code&gt; a
&lt;code&gt;Election&lt;/code&gt; en la salida:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;tibble(
select(pres_results, Election = year, state, total_votes)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 561 × 3
   Election state total_votes
      &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;
 1     1976 AK         123574
 2     1976 AL        1182850
 3     1976 AR         767535
 4     1976 AZ         742719
 5     1976 CA        7803770
 6     1976 CO        1081440
 7     1976 CT        1386355
 8     1976 DC         168830
 9     1976 DE         235642
10     1976 FL        3150631
# … with 551 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="selección-por-rango-de-nombre"&gt;Selección por rango de
nombre&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;select(my_data_frame, column_start:column_end)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cuando usamos la función &lt;code&gt;select()&lt;/code&gt; y definimos las
columnas que queremos mantener, &lt;strong&gt;dplyr&lt;/strong&gt; en realidad no
usa el nombre de las columnas sino el índice de las columnas en el marco
de datos. Esto significa que, cuando definimos las primeras tres
columnas del marco de datos &lt;code&gt;pres_results&lt;/code&gt;,
&lt;code&gt;year&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt; y &lt;code&gt;total_votes&lt;/code&gt;,
&lt;strong&gt;dplyr&lt;/strong&gt; convierte estos nombres en los valores de índice
&lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; y &lt;code&gt;3&lt;/code&gt;. Por lo tanto, también
podemos usar el nombre de las columnas, aplicar el operador
&lt;code&gt;:&lt;/code&gt; y definir rangos de columnas, que queremos mantener:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;tibble(
select(pres_results, year:total_votes)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 561 × 3
    year state total_votes
   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;
 1  1976 AK         123574
 2  1976 AL        1182850
 3  1976 AR         767535
 4  1976 AZ         742719
 5  1976 CA        7803770
 6  1976 CO        1081440
 7  1976 CT        1386355
 8  1976 DC         168830
 9  1976 DE         235642
10  1976 FL        3150631
# … with 551 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lo que hace &lt;code&gt;year:total_votes&lt;/code&gt;, se puede traducir a
&lt;code&gt;1:3&lt;/code&gt;, que es simplemente crear un vector de valores
numéricos del 1 al 3. Luego, la función &lt;code&gt;select()&lt;/code&gt; toma el
marco de datos &lt;code&gt;pres_results&lt;/code&gt; y genera un subconjunto del
mismo, manteniendo solo Las primeras tres columnas.&lt;/p&gt;
&lt;h3 id="select-por-índices"&gt;Select() por índices&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;select(my_data_frame, index_one, index_two, ...)
select(my_data_frame, index_start:index_end)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La función &lt;code&gt;select()&lt;/code&gt; también se puede usar con índices de
columna. En lugar de usar nombres, debemos especificar las columnas que
queremos seleccionar por sus índices. En comparación con otros lenguajes
de programación, la indexación en R comienza con &lt;em&gt;uno&lt;/em&gt; en lugar
de &lt;em&gt;cero&lt;/em&gt;. Para seleccionar la primera, cuarta y quinta columna
del conjunto de datos &lt;code&gt;pres_results&lt;/code&gt; podemos escribir&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;tibble(
select(pres_results, 1,4,5)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 561 × 3
    year   dem   rep
   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
 1  1976 0.357 0.579
 2  1976 0.557 0.426
 3  1976 0.650 0.349
 4  1976 0.398 0.564
 5  1976 0.480 0.497
 6  1976 0.426 0.540
 7  1976 0.467 0.519
 8  1976 0.816 0.165
 9  1976 0.520 0.466
10  1976 0.519 0.466
# … with 551 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;De manera similar a la definición de rangos de columnas usando sus
nombres, podemos definir rangos (o vectores) de valores de índice en su
lugar:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;tibble(
select(pres_results, 1:3)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 561 × 3
    year state total_votes
   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;
 1  1976 AK         123574
 2  1976 AL        1182850
 3  1976 AR         767535
 4  1976 AZ         742719
 5  1976 CA        7803770
 6  1976 CO        1081440
 7  1976 CT        1386355
 8  1976 DC         168830
 9  1976 DE         235642
10  1976 FL        3150631
# … with 551 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="filtrar-filas-de-marcos-de-datos"&gt;Filtrar filas de marcos de
datos&lt;/h2&gt;
&lt;p&gt;A menudo queremos operar sólo en un subconjunto específico de filas
de un marco de datos. La función &lt;strong&gt;dplyr&lt;/strong&gt;
&lt;code&gt;filter()&lt;/code&gt; proporciona una forma flexible de extraer las
filas de interés en base a múltiples condiciones.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Utilice la función &lt;code&gt;filter()&lt;/code&gt; para ordenar las filas de
un marco de datos que cumplan una condición específica&lt;/li&gt;
&lt;li&gt;Filtrar un cuadro de datos por múltiples condiciones&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="r"&gt;&lt;code&gt;filter(my_data_frame, condition)
filter(my_data_frame, condition_one, condition_two, ...)&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="función-filter"&gt;Función filter()&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;filter(my_data_frame, condition)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La función &lt;code&gt;filter()&lt;/code&gt; toma un marco de datos y una o más
expresiones de filtrado como parámetros de entrada. Procesa el marco de
datos y mantiene solo las filas que cumplen con las expresiones de
filtrado definidas. Estas expresiones pueden verse como reglas para la
evaluación y el mantenimiento de filas. En la mayoría de los casos, se
basan en operadores relacionales. Como ejemplo, podríamos filtrar el
marco de datos &lt;code&gt;pres_results&lt;/code&gt; y mantener solo las filas,
donde la variable de &lt;code&gt;state&lt;/code&gt; es igual a &lt;code&gt;"CA"&lt;/code&gt;
(California):&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;tibble(
filter(pres_results, state == &amp;quot;CA&amp;quot;)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 11 × 6
    year state total_votes   dem   rep  other
   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
 1  1976 CA        7803770 0.480 0.497 0.0230
 2  1980 CA        8582938 0.359 0.527 0.114 
 3  1984 CA        9505041 0.413 0.575 0.0122
 4  1988 CA        9887065 0.476 0.511 0.0131
 5  1992 CA       11131721 0.460 0.326 0.213 
 6  1996 CA       10019469 0.511 0.382 0.107 
 7  2000 CA       10965822 0.534 0.417 0.0490
 8  2004 CA       12421353 0.543 0.444 0.0117
 9  2008 CA       13561900 0.610 0.370 0.0188
10  2012 CA       13038547 0.602 0.371 0.0246
11  2016 CA       14181595 0.617 0.316 0.0581&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En el resultado, podemos comparar los resultados de las elecciones en
California para diferentes años.&lt;/p&gt;
&lt;p&gt;Como otro ejemplo, podríamos filtrar el marco de datos
&lt;code&gt;pres_results&lt;/code&gt; y mantener solo aquellas filas, donde la
variable &lt;code&gt;dem&lt;/code&gt; (porcentaje de votos para el Partido
Demócrata) es mayor que 0.85:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;tibble(
filter(pres_results, dem &amp;gt; 0.85)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 7 × 6
   year state total_votes   dem    rep   other
  &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;
1  1984 DC         211288 0.854 0.137  0.00886
2  1996 DC         185726 0.852 0.0934 0.0513 
3  2000 DC         201894 0.852 0.0895 0.0563 
4  2004 DC         227586 0.892 0.0934 0.0125 
5  2008 DC         265853 0.925 0.0653 0.00582
6  2012 DC         293764 0.909 0.0728 0.0155 
7  2016 DC         312575 0.905 0.0407 0.0335 &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En el resultado podemos ver para cada año electoral los estados donde
el Partido Demócrata obtuvo más del 85% de los votos. Según los
resultados, podríamos decir que el Partido Demócrata tiene una base
sólida de votantes en el Distrito de Columbia (conocido como Washington,
D.C.).&lt;/p&gt;
&lt;h3 id="múltiples-expresiones-de-filtro"&gt;Múltiples expresiones de
filtro&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;filter(my_data_frame, condition_one, condition_two, ...)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La función &lt;code&gt;filter()&lt;/code&gt; también puede tomar múltiples reglas
de filtrado como entrada. Estos pueden verse como una combinación de
reglas con el operador &lt;code&gt;&amp;amp;&lt;/code&gt;. Para que una fila se incluya
en la salida, todas las reglas de filtrado deben cumplirse. En el
siguiente ejemplo, filtramos el marco de datos &lt;code&gt;pres_results&lt;/code&gt;
para todas las filas donde la variable &lt;code&gt;state&lt;/code&gt; es igual a
&lt;code&gt;"CA"&lt;/code&gt; y la variable de &lt;code&gt;year&lt;/code&gt; es igual a
2016:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;tibble(
filter(pres_results, state == &amp;quot;CA&amp;quot;, year==2016)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 1 × 6
   year state total_votes   dem   rep  other
  &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
1  2016 CA       14181595 0.617 0.316 0.0581&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obtenemos una sola fila como salida, que contiene los resultados de
las elecciones presidenciales de 2016 en los Estados Unidos para el
estado de California.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ejercicio: Usar filter() con múltiples reglas&lt;/strong&gt; El
conjunto de datos del &lt;code&gt;gapminder&lt;/code&gt; contiene datos económicos y
demográficos sobre diversos países desde 1952. Filtra el tibble e
inspecciona qué países tenían una esperanza de vida de más de 80 años en
el año 2007. Los paquetes necesarios ya están cargados.&lt;/p&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;Utiliza la función &lt;code&gt;filter()&lt;/code&gt; en el tibble de
gapminder.&lt;/li&gt;
&lt;li&gt;Filtra todas las filas en las que la variable &lt;code&gt;year&lt;/code&gt; es
igual a 2007 y la esperanza de vida &lt;code&gt;lifeExp&lt;/code&gt; es mayor de
80!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Solución&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;tibble(
filter(gapminder, year==2007, lifeExp &amp;gt; 80)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 13 × 6
   country          continent  year lifeExp       pop gdpPercap
   &amp;lt;fct&amp;gt;            &amp;lt;fct&amp;gt;     &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;     &amp;lt;dbl&amp;gt;
 1 Australia        Oceania    2007    81.2  20434176    34435.
 2 Canada           Americas   2007    80.7  33390141    36319.
 3 France           Europe     2007    80.7  61083916    30470.
 4 Hong Kong, China Asia       2007    82.2   6980412    39725.
 5 Iceland          Europe     2007    81.8    301931    36181.
 6 Israel           Asia       2007    80.7   6426679    25523.
 7 Italy            Europe     2007    80.5  58147733    28570.
 8 Japan            Asia       2007    82.6 127467972    31656.
 9 New Zealand      Oceania    2007    80.2   4115771    25185.
10 Norway           Europe     2007    80.2   4627926    49357.
11 Spain            Europe     2007    80.9  40448191    28821.
12 Sweden           Europe     2007    80.9   9031088    33860.
13 Switzerland      Europe     2007    81.7   7554661    37506.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Ejercicio&lt;/strong&gt; El conjunto de datos del
&lt;code&gt;gapminder&lt;/code&gt; contiene datos económicos y demográficos sobre
diversos países desde 1952. Filtra el tibble de &lt;code&gt;gapminder&lt;/code&gt; e
inspecciona qué países tenían una población de más de 1.000.000.000 en
el año 2007! Los paquetes necesarios ya están cargados.&lt;/p&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;Utiliza la función &lt;code&gt;filter()&lt;/code&gt; en el tibble
&lt;code&gt;gapminder&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Filtra todas las filas donde la variable &lt;code&gt;year&lt;/code&gt; es igual
a 2007 y la población &lt;code&gt;pop&lt;/code&gt; es mayor de 1000000000!&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="r"&gt;&lt;code&gt;filter(gapminder, year==2007, pop &amp;gt; 1000000000)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 2 × 6
  country continent  year lifeExp        pop gdpPercap
  &amp;lt;fct&amp;gt;   &amp;lt;fct&amp;gt;     &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;      &amp;lt;int&amp;gt;     &amp;lt;dbl&amp;gt;
1 China   Asia       2007    73.0 1318683096     4959.
2 India   Asia       2007    64.7 1110396331     2452.&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="ordenar-marcos-de-datos-por-columnas"&gt;Ordenar marcos de datos
por columnas&lt;/h2&gt;
&lt;p&gt;Para seleccionar las áreas de interés en un marco de datos, a menudo
es necesario ordenarlas por columnas específicas. La función
&lt;strong&gt;dplyr&lt;/strong&gt; &lt;code&gt;arrange()&lt;/code&gt; permite ordenar los marcos
de datos por múltiples columnas en orden ascendente y descendente.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Utilice la función &lt;code&gt;arrange()&lt;/code&gt; para ordenar los marcos de
datos.&lt;/li&gt;
&lt;li&gt;Ordene los marcos de datos por múltiples columnas usando
&lt;code&gt;arrange()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;arrange(my_data_frame, column_one)
arrange(my_data_frame, column_one, column_two, ...)&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="la-función-arrange-con-una-sola-columna"&gt;La función arrange()
con una sola columna&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;arrange(my_data_frame, column_one)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La función &lt;code&gt;arrange()&lt;/code&gt; ordena las filas de un marco de
datos. Toma un marco de datos o un tibble como primer parámetro y los
nombres de las columnas en función de los cuales las filas deben
ordenarse como parámetros adicionales. Supongamos que queremos responder
la pregunta: &lt;em&gt;¿Qué estados tuvieron el mayor porcentaje de votantes
republicanos en las elecciones presidenciales de 2016 en los Estados
Unidos?&lt;/em&gt; Para responder a esta pregunta, en el siguiente ejemplo
usamos el marco de datos &lt;code&gt;pres_results_2016&lt;/code&gt;, que contiene
información solo para las elecciones presidenciales de EE.UU. de 2016.
Nuestra función &lt;code&gt;arrange()&lt;/code&gt; en el marco de datos
&lt;code&gt;rep&lt;/code&gt; basado en la columna (votos republicanos en
porcentaje):&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;pres_results_2016 &amp;lt;- pres_results %&amp;gt;%
  filter(year==2016)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;tibble(
arrange(pres_results_2016, rep)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 51 × 6
    year state total_votes   dem    rep  other
   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
 1  2016 DC         312575 0.905 0.0407 0.0335
 2  2016 HI         437664 0.610 0.294  0.0958
 3  2016 VT         320467 0.557 0.298  0.0737
 4  2016 CA       14181595 0.617 0.316  0.0581
 5  2016 MA        3378821 0.591 0.323  0.0858
 6  2016 MD        2781446 0.603 0.339  0.0415
 7  2016 NY        7802084 0.584 0.361  0.0530
 8  2016 WA        3317019 0.525 0.368  0.0738
 9  2016 IL        5536424 0.558 0.388  0.0517
10  2016 RI         464144 0.544 0.389  0.0466
# … with 41 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como puede ver en la salida, el marco de datos se ordena en orden
ascendente según la columna &lt;code&gt;rep&lt;/code&gt;. Sin embargo, preferiríamos
tener los resultados en orden descendente, para que podamos ver
instantáneamente &lt;code&gt;state&lt;/code&gt; con el mayor porcentaje de
repeticiones. Para ordenar una columna en orden descendente, todo lo que
tenemos que hacer es aplicar la función &lt;code&gt;desc()&lt;/code&gt; en la
columna dada dentro de la función &lt;code&gt;arrange()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;tibble(
arrange(pres_results_2016, desc(rep))
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 51 × 6
    year state total_votes   dem   rep  other
   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
 1  2016 WV         713051 0.265 0.686 0.0489
 2  2016 WY         258788 0.216 0.674 0.0830
 3  2016 OK        1452992 0.289 0.653 0.0575
 4  2016 ND         344360 0.272 0.630 0.0971
 5  2016 KY        1924149 0.327 0.625 0.0476
 6  2016 AL        2123372 0.344 0.621 0.0254
 7  2016 SD         370093 0.317 0.615 0.0673
 8  2016 TN        2508027 0.347 0.607 0.0401
 9  2016 AR        1130635 0.337 0.606 0.0577
10  2016 ID         690255 0.275 0.593 0.132 
# … with 41 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La organización no solo es posible en valores numéricos, sino también
en valores de caracteres. En ese caso, &lt;strong&gt;dplyr&lt;/strong&gt; ordena las
filas en orden alfabético. Podemos organizar columnas de caracteres como
las numéricas:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;tibble(
arrange(pres_results_2016, state)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 51 × 6
    year state total_votes   dem    rep  other
   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
 1  2016 AK         318608 0.366 0.513  0.0928
 2  2016 AL        2123372 0.344 0.621  0.0254
 3  2016 AR        1130635 0.337 0.606  0.0577
 4  2016 AZ        2573165 0.451 0.487  0.0547
 5  2016 CA       14181595 0.617 0.316  0.0581
 6  2016 CO        2780220 0.482 0.433  0.0859
 7  2016 CT        1644920 0.546 0.409  0.0435
 8  2016 DC         312575 0.905 0.0407 0.0335
 9  2016 DE         441590 0.534 0.419  0.0472
10  2016 FL        9420039 0.478 0.490  0.0315
# … with 41 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="la-función-arrange-con-múltiples-columnas"&gt;La función arrange()
con múltiples columnas&lt;/h3&gt;
&lt;p&gt;También podemos usar la función &lt;code&gt;arrange()&lt;/code&gt; en varias
columnas. En este caso, el orden de las columnas en los parámetros de la
función establece una jerarquía de ordenamiento. La función comienza
ordenando las filas en función de la primera columna definida en los
parámetros. En caso de que haya varias filas con el mismo valor, la
función decide el orden en función de la segunda columna definida en los
parámetros. Si todavía hay varias filas con los mismos valores, la
función decide en función de la tercera columna definida en los
parámetros (si está definida) y así sucesivamente.&lt;/p&gt;
&lt;p&gt;En el siguiente ejemplo, utilizamos el marco de datos
&lt;code&gt;pres_results_subset&lt;/code&gt;, que contiene los resultados de las
elecciones solo para los estados: &lt;code&gt;"TX"&lt;/code&gt; (Texas),
&lt;code&gt;"UT"&lt;/code&gt; (Utah) y &lt;code&gt;"FL"&lt;/code&gt; (Florida). Primero
ordenamos el marco de datos en orden descendente según la columna de
year. Luego, agregamos un segundo nivel y ordenamos el marco de datos
basado en la columna &lt;code&gt;dem&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;pres_results_subset &amp;lt;- pres_results %&amp;gt;%
  filter(state %in% c(&amp;quot;TX&amp;quot;,
                      &amp;quot;UT&amp;quot;,
                      &amp;quot;FL&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;tibble(
arrange(pres_results_subset, year, dem)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 33 × 6
    year state total_votes   dem   rep    other
   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
 1  1976 UT         541218 0.336 0.624 0.0392  
 2  1976 TX        4071884 0.511 0.480 0.00817 
 3  1976 FL        3150631 0.519 0.466 0.0143  
 4  1980 UT         604152 0.206 0.728 0.0665  
 5  1980 FL        3686927 0.385 0.555 0.0597  
 6  1980 TX        4541636 0.414 0.553 0.0329  
 7  1984 UT         629656 0.247 0.745 0.00823 
 8  1984 FL        4180051 0.347 0.653 0.000212
 9  1984 TX        5397571 0.361 0.636 0.00275 
10  1988 UT         647008 0.320 0.662 0.0173  
# … with 23 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como puede ver en la salida, el marco de datos se ordena en general
en función de la columna &lt;code&gt;year&lt;/code&gt;. Sin embargo, cuando el valor
de &lt;code&gt;year&lt;/code&gt; es el mismo, el orden de las filas lo decide la
columna &lt;code&gt;dem&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="crear-una-tubería-de-transformación-de-datos"&gt;Crear una tubería
de transformación de datos&lt;/h2&gt;
&lt;p&gt;Todas las funciones de transformación de datos en
&lt;strong&gt;dplyr&lt;/strong&gt; pueden ser conectadas a través del operador de
tubería (pipe) &lt;code&gt;%&amp;gt;%&lt;/code&gt; para crear poderosas y a la vez
expresivas tuberías de transformación de datos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Utilice el operador pipe &lt;code&gt;%&amp;gt;%&lt;/code&gt; para combinar múltiples
funciones &lt;strong&gt;dplyr&lt;/strong&gt; en una tubería&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="r"&gt;&lt;code&gt;my_data_frame %&amp;gt;%
  filter(___) %&amp;gt;%
  select(___) %&amp;gt;%
  arrange(___)&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="usando-el-operador"&gt;Usando el operador %&amp;gt;%&lt;/h3&gt;
&lt;p&gt;El operador pipe &lt;code&gt;%&amp;gt;%&lt;/code&gt; es una parte especial del
universo &lt;code&gt;tidyverse&lt;/code&gt;. Se utiliza para combinar múltiples
funciones y ejecutarlas una tras otra. En esta configuración, la entrada
de cada función es la salida de la función anterior. Imagine que tenemos
el marco de datos &lt;code&gt;pres_results&lt;/code&gt; y queremos crear un marco de
datos más pequeño y transparente para responder a la pregunta: &lt;em&gt;¿En
qué estados fue el partido democrático la opción más popular en las
elecciones presidenciales de 2016 en los Estados Unidos?&lt;/em&gt; Para
lograr esta tarea, deberíamos seguir los siguientes pasos:&lt;/p&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;&lt;code&gt;filter()&lt;/code&gt; el marco de datos para las filas, donde la
variable &lt;code&gt;year&lt;/code&gt; es igual a 2016&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select()&lt;/code&gt; las dos variables &lt;code&gt;state&lt;/code&gt; y
&lt;code&gt;dem&lt;/code&gt;, ya que no estamos interesados en el resto de las
columnas.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arrange()&lt;/code&gt; el marco de datos filtrado y seleccionado en
función de la columna &lt;code&gt;dem&lt;/code&gt; de forma descendente.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Los pasos y funciones descritos anteriormente deben ejecutarse uno
tras otro, donde la entrada de cada función es la salida del paso
anterior. Aplicando las cosas que aprendió hasta ahora, puede realizar
esta tarea siguiendo los siguientes pasos:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;result &amp;lt;- filter(pres_results, year==2016)
result &amp;lt;- select(result, state, dem)
result &amp;lt;- arrange(result, desc(dem))
tibble(result)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 51 × 2
   state   dem
   &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
 1 DC    0.905
 2 CA    0.617
 3 HI    0.610
 4 MD    0.603
 5 MA    0.591
 6 NY    0.584
 7 IL    0.558
 8 VT    0.557
 9 NJ    0.555
10 CT    0.546
# … with 41 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La primera función toma el marco de datos &lt;code&gt;pres_results&lt;/code&gt;,
lo filtra de acuerdo con la descripción de la tarea y lo asigna a la
variable &lt;code&gt;result&lt;/code&gt;. Luego, cada función posterior toma la
variable &lt;code&gt;result&lt;/code&gt; como entrada y la sobrescribe con su propia
salida.&lt;/p&gt;
&lt;p&gt;El operador &lt;code&gt;%&amp;gt;%&lt;/code&gt; proporciona una forma práctica de
combinar los pasos anteriores en aparentemente un paso. Toma un marco de
datos como entrada inicial. Luego, aplica una lista de funciones y pasa
la salida de cada función para la entrada de la siguiente función. La
misma tarea que la anterior se puede lograr usando el operador de
tubería &lt;code&gt;%&amp;gt;%&lt;/code&gt; de esta manera:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;tibble(
pres_results %&amp;gt;%
  filter(year==2016) %&amp;gt;%
  select(state, dem, rep) %&amp;gt;%
  arrange(desc(dem))
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 51 × 3
   state   dem    rep
   &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
 1 DC    0.905 0.0407
 2 CA    0.617 0.316 
 3 HI    0.610 0.294 
 4 MD    0.603 0.339 
 5 MA    0.591 0.323 
 6 NY    0.584 0.361 
 7 IL    0.558 0.388 
 8 VT    0.557 0.298 
 9 NJ    0.555 0.414 
10 CT    0.546 0.409 
# … with 41 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Podemos interpretar el código de la siguiente manera:&lt;/p&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;Definimos el conjunto de datos original como punto de partida.&lt;/li&gt;
&lt;li&gt;El uso del operador &lt;code&gt;%&amp;gt;%&lt;/code&gt; justo después del marco de
datos le dice a &lt;strong&gt;dplyr&lt;/strong&gt;, que viene una función, que toma
el marco de datos previamente definido como entrada.&lt;/li&gt;
&lt;li&gt;Usamos cada función como de costumbre, pero omite el primer
parámetro. La entrada del marco de datos se proporciona automáticamente
por la salida del paso anterior.&lt;/li&gt;
&lt;li&gt;Mientras agreguemos el operador &lt;code&gt;%&amp;gt;%&lt;/code&gt; después de un
paso, &lt;strong&gt;dplyr&lt;/strong&gt; esperará un paso adicional.&lt;/li&gt;
&lt;li&gt;En nuestro ejemplo, la tubería se cierra con una función
&lt;code&gt;arrange()&lt;/code&gt;. Obtiene la versión filtrada y seleccionada del
marco de datos &lt;code&gt;pres_results&lt;/code&gt; como entrada y la ordena en
función de la columna &lt;code&gt;dem&lt;/code&gt; de forma descendente. Finalmente,
devuelve la salida.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Una diferencia entre los dos enfoques es que el operador
&lt;code&gt;%&amp;gt;%&lt;/code&gt; no guarda permanentemente los resultados intermedios
o finales. Para guardar el marco de datos resultante, debemos asignar la
salida a una variable:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;result &amp;lt;- pres_results %&amp;lt;&amp;gt;%
  filter(year==2016) %&amp;gt;%
  select(state, dem) %&amp;gt;%
  arrange(desc(dem))
tibble(result)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 51 × 2
   state   dem
   &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
 1 DC    0.905
 2 CA    0.617
 3 HI    0.610
 4 MD    0.603
 5 MA    0.591
 6 NY    0.584
 7 IL    0.558
 8 VT    0.557
 9 NJ    0.555
10 CT    0.546
# … with 41 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="ejercicios"&gt;Ejercicios:&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Esperanza de vida austriaca&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Utiliza el operador &lt;code&gt;%&amp;gt;%&lt;/code&gt; en el conjunto de datos de
&lt;code&gt;gapminder&lt;/code&gt; y crea un simple marco de datos para responder a
la siguiente pregunta: &lt;em&gt;¿Cómo ha cambiado la esperanza de vida en
Austria en las últimas décadas?&lt;/em&gt; Los paquetes necesarios ya están
cargados.&lt;/p&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;Defina el marco de datos de &lt;code&gt;gapminder&lt;/code&gt; como el marco de
datos de base&lt;/li&gt;
&lt;li&gt;Filtra sólo las filas en las que la columna &lt;code&gt;country&lt;/code&gt; es
igual a &lt;code&gt;Austria&lt;/code&gt; mediante la tubería &lt;code&gt;gapminder&lt;/code&gt;
a la función &lt;code&gt;filter()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Selecciona sólo las columnas: &lt;code&gt;year&lt;/code&gt; y
&lt;code&gt;lifeExp&lt;/code&gt; del resultado filtrado.&lt;/li&gt;
&lt;li&gt;Ordena los resultados en base a la columna &lt;code&gt;year&lt;/code&gt; en
función de las columnas seleccionadas.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Solución:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;gapminder %&amp;gt;%
  filter(country == &amp;quot;Austria&amp;quot;) %&amp;gt;%
  select(year, lifeExp) %&amp;gt;%
  arrange(year)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 12 × 2
    year lifeExp
   &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;
 1  1952    66.8
 2  1957    67.5
 3  1962    69.5
 4  1967    70.1
 5  1972    70.6
 6  1977    72.2
 7  1982    73.2
 8  1987    74.9
 9  1992    76.0
10  1997    77.5
11  2002    79.0
12  2007    79.8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;PIB europeo per cápita&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Utiliza el operador &lt;code&gt;%&amp;gt;%&lt;/code&gt; en el conjunto de datos de
&lt;code&gt;gapminder&lt;/code&gt; y crea un simple tibble para responder a la
siguiente pregunta: &lt;em&gt;¿Qué país europeo tuvo el mayor PIB per cápita
en 2007?&lt;/em&gt; Los paquetes requeridos ya están cargados.&lt;/p&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;Defina el tibble de &lt;code&gt;gapminder&lt;/code&gt; como la entrada&lt;/li&gt;
&lt;li&gt;Filtra sólo las filas donde la columna &lt;code&gt;year&lt;/code&gt; es igual a
&lt;code&gt;2007&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Usar una segunda capa de filtro y mantener sólo las filas donde la
columna del continente es igual a &lt;code&gt;Europe&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Seleccione sólo las columnas: &lt;code&gt;country&lt;/code&gt; y
&lt;code&gt;gdpPercap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Ordena los resultados basados en la columna &lt;code&gt;gdpPercap&lt;/code&gt;
de forma descendente&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="r"&gt;&lt;code&gt;gapminder %&amp;gt;%
  filter(year == 2007, continent == &amp;quot;Europe&amp;quot;) %&amp;gt;%
  select(country, gdpPercap) %&amp;gt;%
  arrange(desc(gdpPercap))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 30 × 2
   country     gdpPercap
   &amp;lt;fct&amp;gt;           &amp;lt;dbl&amp;gt;
 1 Norway         49357.
 2 Ireland        40676.
 3 Switzerland    37506.
 4 Netherlands    36798.
 5 Iceland        36181.
 6 Austria        36126.
 7 Denmark        35278.
 8 Sweden         33860.
 9 Belgium        33693.
10 Finland        33207.
# … with 20 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Población de las Américas&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Utiliza el operador &lt;code&gt;%&amp;gt;%&lt;/code&gt; en el conjunto de datos de
&lt;code&gt;gapminder&lt;/code&gt; y crea un simple tibble para responder a la
siguiente pregunta: &lt;em&gt;¿Qué país del continente americano tenía la
mayor población en 2007?&lt;/em&gt;&lt;/p&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;Defina el tibble de &lt;code&gt;gapminder&lt;/code&gt; como la entrada&lt;/li&gt;
&lt;li&gt;Filtra sólo las filas donde la columna &lt;code&gt;year&lt;/code&gt; es igual a
&lt;code&gt;2007&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Utilice una segunda capa de filtro y mantenga sólo las filas donde
la columna del &lt;code&gt;continent&lt;/code&gt; es igual a
&lt;code&gt;Americas&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Seleccione sólo las columnas: &lt;code&gt;country&lt;/code&gt; y
&lt;code&gt;pop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Arregla los resultados basados en la columna &lt;code&gt;pop&lt;/code&gt; de
forma descendente&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="r"&gt;&lt;code&gt;gapminder %&amp;gt;%
  filter(year == 2007, continent == &amp;quot;Americas&amp;quot;) %&amp;gt;%
  select(country, pop) %&amp;gt;%
  arrange(desc(pop))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 25 × 2
   country             pop
   &amp;lt;fct&amp;gt;             &amp;lt;int&amp;gt;
 1 United States 301139947
 2 Brazil        190010647
 3 Mexico        108700891
 4 Colombia       44227550
 5 Argentina      40301927
 6 Canada         33390141
 7 Peru           28674757
 8 Venezuela      26084662
 9 Chile          16284741
10 Ecuador        13755680
# … with 15 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r distill-force-highlighting-css"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      <distill:md5>75b4d908541b770d13517beb27a9e9fd</distill:md5>
      <category>Dplyr</category>
      <category>Data Science</category>
      <category>Tidyverse</category>
      <guid>https://franklinsantos.com/posts/2022-01-10-diplyr</guid>
      <pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate>
      <media:content url="https://franklinsantos.com/posts/2022-01-10-diplyr/fs.png" medium="image" type="image/png" width="2214" height="2556"/>
    </item>
    <item>
      <title>Explorador de datos sobre emisiones de CO2</title>
      <dc:creator>Franklin Santos</dc:creator>
      <link>https://franklinsantos.com/posts/2021-11-21-co2</link>
      <description>Las emisiones de dióxido de carbono y otros gases de efecto invernadero son uno de los principales motores del cambio climático.</description>
      <category>CO2</category>
      <category>Climate Change</category>
      <category>Carbon Dioxide</category>
      <guid>https://franklinsantos.com/posts/2021-11-21-co2</guid>
      <pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate>
      <media:content url="https://franklinsantos.com/posts/2021-11-21-co2/fs.png" medium="image" type="image/png" width="1454" height="1044"/>
    </item>
    <item>
      <title>Marco de datos y tibbles</title>
      <dc:creator>Franklin Santos</dc:creator>
      <link>https://franklinsantos.com/posts/2021-11-21-tibbles</link>
      <description>Abordamos la primera etapa en el manejo de datos. Podrá explorar la base de datos. Para ello, tiene que familiarizarse con las funciones de marco de datos base de R y también verá las funciones del paquete tibbles que es parte de tidyverse de RStudio.</description>
      <category>Data Framework</category>
      <category>Tibbles</category>
      <category>Data Science</category>
      <guid>https://franklinsantos.com/posts/2021-11-21-tibbles</guid>
      <pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate>
      <media:content url="https://franklinsantos.com/posts/2021-11-21-tibbles/download.jpeg" medium="image" type="image/jpeg"/>
    </item>
    <item>
      <title>Introducción a R básico</title>
      <dc:creator>Franklin Santos</dc:creator>
      <link>https://franklinsantos.com/posts/2021-10-24-r-intro</link>
      <description>Es una introducción al manejo y uso básico a la plataforma de R. Este software es muy popular e increíblemente útil para las personas que trabajan como científicos de datos o en empresas.</description>
      <category>R</category>
      <category>R Basic</category>
      <category>Data Science</category>
      <guid>https://franklinsantos.com/posts/2021-10-24-r-intro</guid>
      <pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate>
      <media:content url="https://franklinsantos.com/posts/2021-10-24-r-intro/Rfs.png" medium="image" type="image/png" width="200" height="231"/>
    </item>
    <item>
      <title>Herramientas estadísticas y experimentales en el mejoramiento de plantas</title>
      <dc:creator>Franklin Santos</dc:creator>
      <link>https://franklinsantos.com/posts/2021-09-02-inkaverse</link>
      <description>En esta oportunidad hacemos referencia a una colección de aplicaciones (inkaverse) para los procedimientos de diseño experimental y análisis estadístico.</description>
      <category>Inkaverse</category>
      <category>Experimental Design</category>
      <category>Plant Breeding</category>
      <guid>https://franklinsantos.com/posts/2021-09-02-inkaverse</guid>
      <pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate>
      <media:content url="https://franklinsantos.com/posts/2021-09-02-inkaverse/inkaverse.png" medium="image" type="image/png" width="518" height="600"/>
    </item>
    <item>
      <title>Área foliar e índice de severidad con R</title>
      <dc:creator>Franklin Santos</dc:creator>
      <link>https://franklinsantos.com/posts/2021-08-06-pliman</link>
      <description>Les presento una alternativa para hallar área foliar e indice de severidad de enfermedades foliares utilizando el paquete pliman. pliman (PLant IMage ANalysis) es un paquete de R para el análisis de imágenes de plantas, principalmente de hojas.</description>
      <category>Leaf Area</category>
      <category>Pliman</category>
      <category>Disease Severity</category>
      <guid>https://franklinsantos.com/posts/2021-08-06-pliman</guid>
      <pubDate>Fri, 06 Aug 2021 00:00:00 +0000</pubDate>
      <media:content url="https://franklinsantos.com/posts/2021-08-06-pliman/pliman_files/figure-html5/unnamed-chunk-7-1.png" medium="image" type="image/png" width="1248" height="768"/>
    </item>
    <item>
      <title>Tendencias de rendimiento de los cultivos</title>
      <dc:creator>Franklin Santos</dc:creator>
      <link>https://franklinsantos.com/posts/2021-07-13-crop-model-yield</link>
      <description>Se presenta las tendencias de rendimiento de los principales cultivos en los diez paises más poblados del mundo.</description>
      <category>Crop Yield</category>
      <category>Model</category>
      <category>TidyTuesday</category>
      <guid>https://franklinsantos.com/posts/2021-07-13-crop-model-yield</guid>
      <pubDate>Tue, 13 Jul 2021 00:00:00 +0000</pubDate>
      <media:content url="https://franklinsantos.com/posts/2021-07-13-crop-model-yield/crop-model-yield_files/figure-html5/unnamed-chunk-8-1.png" medium="image" type="image/png" width="1248" height="768"/>
    </item>
    <item>
      <title>Cosecha de datos de la web</title>
      <dc:creator>Franklin Santos</dc:creator>
      <link>https://franklinsantos.com/posts/2021-05-31-webscraping</link>
      <description>Se realiza una introducción al web scraping con el paquete rvest para la cosecha de datos de la web.</description>
      <category>Web Scraping</category>
      <category>Rvest</category>
      <category>Worldmeter</category>
      <guid>https://franklinsantos.com/posts/2021-05-31-webscraping</guid>
      <pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate>
      <media:content url="https://franklinsantos.com/posts/2021-05-31-webscraping/logo.png" medium="image" type="image/png" width="240" height="278"/>
    </item>
  </channel>
</rss>
